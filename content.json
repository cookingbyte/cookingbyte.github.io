{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/1985/10/26/hello-world/"},{"title":"基础项目开发","text":"养老项目一、基础数据开发前瞻知识点 为什么要区分 DTO 和 VO 对象？ 因为有些情况不想传完整的数据进去，vo相当于能过滤一遍，只发送必要的数据。 护理接口分页查询数据创建一个dto对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 护理项目数据传输对象 */@Datapublic class NursingProjectDto extends BaseDto { /** * 名称 */ @ApiModelProperty(value = &quot;名称&quot;) private String name; /** * 排序号 */ @ApiModelProperty(value = &quot;排序号&quot;) private Integer orderNo; /** * 单位 */ @ApiModelProperty(value = &quot;单位&quot;) private String unit; /** * 价格 */ @ApiModelProperty(value = &quot;价格&quot;) private BigDecimal price; /** * 图片 */ @ApiModelProperty(value = &quot;图片&quot;) private String image; /** * 护理要求 */ @ApiModelProperty(value = &quot;护理要求&quot;) private String nursingRequirement; /** * 状态（0：禁用，1：启用） */ @ApiModelProperty(value = &quot;状态（0：禁用，1：启用）&quot;) private Integer status;} Controll12345678910111213141516171819202122232425/** * @author geb * @create 2025-01-27-10:59 AM */@RestController@RequestMapping(&quot;/nursing_project&quot;)public class NursingProjectController extends BaseController{ @Autowired private NursingProjectService nursingProjectService; @GetMapping public ResponseResult getByPage(@RequestParam(value = &quot;name&quot;, required = false) String name, @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;10&quot;) Integer pageSize, @RequestParam(value = &quot;status&quot;,required = false) Integer status) { PageResponse&lt;NursingProjectVo&gt; page = nursingProjectService.getPage(name, pageNum, pageSize, status); return success(page); }} Service123456789/** * @author geb * @create 2025-02-05-1:34 PM */public interface NursingProjectService { public PageResponse&lt;NursingProjectVo&gt; getPage(String name,Integer pageNum,Integer pageSize,Integer state);} ServiceImpl1234567891011121314151617181920212223/** * @author geb * @create 2025-02-05-1:40 PM */@Servicepublic class NursingProjectServiceImpl implements NursingProjectService { @Autowired private NursingProjectMapper nursingProjectMapper; @Override public PageResponse&lt;NursingProjectVo&gt; getPage(String name, Integer pageNum, Integer pageSize, Integer status) { //分页 PageHelper.startPage(pageNum,pageSize); Page&lt;NursingProjectVo&gt; projectVoPage = nursingProjectMapper.getByPage(name, pageNum, pageSize, status); return PageResponse.of(projectVoPage,NursingProjectVo.class); }} Mapper123456789@Mapperpublic interface NursingProjectMapper { public Page&lt;NursingProjectVo&gt; getByPage( String name, Integer pageNum, Integer pageSize, Integer status );} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.zzyl.mapper.NursingProjectMapper&quot;&gt; &lt;resultMap id=&quot;nursingProjectResultMap&quot; type=&quot;com.zzyl.vo.NursingProjectVo&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;order_no&quot; property=&quot;orderNo&quot;/&gt; &lt;result column=&quot;unit&quot; property=&quot;unit&quot;/&gt; &lt;result column=&quot;price&quot; property=&quot;price&quot;/&gt; &lt;result column=&quot;image&quot; property=&quot;image&quot;/&gt; &lt;result column=&quot;nursing_requirement&quot; property=&quot;nursingRequirement&quot;/&gt; &lt;result column=&quot;status&quot; property=&quot;status&quot;/&gt; &lt;result column=&quot;create_by&quot; property=&quot;createBy&quot;/&gt; &lt;result column=&quot;update_by&quot; property=&quot;updateBy&quot;/&gt; &lt;result column=&quot;remark&quot; property=&quot;remark&quot;/&gt; &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot;/&gt; &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot;/&gt; &lt;result column=&quot;creator&quot; property=&quot;creator&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getByPage&quot; resultMap=&quot;nursingProjectResultMap&quot;&gt; select np.id, np.name, np.order_no, np.unit, np.price, np.image, np.nursing_requirement, np.status, np.create_by, np.update_by, np.remark, np.create_time, np.update_time, su.real_name from nursing_project np left join sys_user su on np.create_by=su.id &lt;where&gt; &lt;if test=&quot;name != null and name != ''&quot;&gt; and name like concat('%',#{name},'%') &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; and status = #{status} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; ![image-20250206114812693](/Users/gebin/Library/Application Support/typora-user-images/image-20250206114812693.png) 新增Controll123456789101112/** * 添加护理项目 * @param nursingProjectDto * @return */ @PostMapping public ResponseResult add(@RequestBody NursingProjectDto nursingProjectDto){ nursingProjectService.add(nursingProjectDto); return success();} Service12345/** * 添加护理项目 * @param nursingProjectDto */ void add(NursingProjectDto nursingProjectDto); ServiceImpl12345678910111213/** * 添加护理项目 * * @param nursingProjectDto */ @Override public void add(NursingProjectDto nursingProjectDto) { //对象的转换 把当前nursingProjectDto 里面的所有属性都拷贝到NursingProject 中，因为nursingProjectDto 中的属性不全 NursingProject nursingProject = BeanUtil.copyProperties(nursingProjectDto, NursingProject.class); //调用mapper nursingProjectMapper.insert(nursingProject); } Mapper1void insert(NursingProject nursingProject); 123456&lt;insert id=&quot;insert&quot;&gt; insert into nursing_project (name, order_no, unit, price, image, nursing_requirement, status, create_by, update_by, remark, create_time, update_time) values (#{name}, #{orderNo}, #{unit}, #{price}, #{image}, #{nursingRequirement}, #{status}, #{createBy}, #{updateBy}, #{remark}, #{createTime}, #{updateTime})&lt;/insert&gt; ![image-20250206170214310](/Users/gebin/Library/Application Support/typora-user-images/image-20250206170214310.png) 编辑回显数据– 根据ID查询数据Controll1234567@GetMapping(&quot;/{id}&quot;) public ResponseResult getById(@PathVariable(&quot;id&quot;) Long id){ NursingProjectVo nursingProjectVo = nursingProjectService.getById(id); return success(nursingProjectVo);} Service123456 /** * 根据id 查询护理项目 * @param id * @return */NursingProjectVo getById(Long id); ServiceImpl12345678910/** * 根据id 查询护理项目 * * @param id * @return */ @Overridepublic NursingProjectVo getById(Long id) { return nursingProjectMapper.getById(id);} Mapper1NursingProjectVo getById(Long id); 12345&lt;select id=&quot;getById&quot; resultMap=&quot;nursingProjectResultMap&quot;&gt; select * from nursing_project where id = #{id}&lt;/select&gt; ![image-20250206175745552](/Users/gebin/Library/Application Support/typora-user-images/image-20250206175745552.png) 此时，回显数据成功 更新数据Controll12345@PutMapping public ResponseResult update(@RequestBody NursingProjectDto nursingProjectDto){ nursingProjectService.update(nursingProjectDto); return success(); } Service12345/** * 修改护理项目 * @param nursingProjectDto */ void update(NursingProjectDto nursingProjectDto); ServiceImpl1234567891011/** * 修改护理项目 * * @param nursingProjectDto */ @Override public void update(NursingProjectDto nursingProjectDto) { NursingProject nursingProject = new NursingProject(); BeanUtils.copyProperties(nursingProjectDto, nursingProject); nursingProjectMapper.update(nursingProject); } Mapper1void update(NursingProject nursingProject); 1234567891011121314&lt;update id=&quot;update&quot;&gt; update nursing_project set name = #{name}, order_no = #{orderNo}, unit = #{unit}, price = #{price}, image = #{image}, nursing_requirement = #{nursingRequirement}, status = #{status}, update_by = #{updateBy}, remark = #{remark}, update_time = #{updateTime} where id = #{id} &lt;/update&gt; 二、微信登录Controll12345678910111213141516@RestController@RequestMapping(&quot;/customer/user&quot;)@Api(tags = &quot;小程序登录&quot;)public class CustomerUserController extends BaseController { @Autowired private MemberService memberService; @PostMapping(&quot;/login&quot;) @ApiOperation(&quot;登录&quot;) public ResponseResult&lt;LoginVo&gt; login(@RequestBody UserLoginRequestDto dto){ LoginVo loginVo = memberService.login(dto); return ResponseResult.success(loginVo); }} Service123456789101112/** * 用户管理 */public interface MemberService { /** * 登录方法 * @param dto * @return */ LoginVo login(UserLoginRequestDto dto);} ServiceImpl获取手机号1234567891011121314151617181920212223242526272829303132333435363738394041/** * 用户管理 */@Slf4j@Servicepublic class MemberServiceImpl implements MemberService { @Autowired private WechatService wechatService; @Autowired private MemberMapper memberMapper; @Autowired private JwtTokenManagerProperties jwtTokenManagerProperties; static ArrayList DEFAULT_NICKNAME_PREFIX = Lists.newArrayList( &quot;生活更美好&quot;, &quot;大桔大利&quot;, &quot;日富一日&quot;, &quot;好柿开花&quot;, &quot;柿柿如意&quot;, &quot;一椰暴富&quot;, &quot;大柚所为&quot;, &quot;杨梅吐气&quot;, &quot;天生荔枝&quot; ); /** * 登录方法 * * @param dto * @return */ @Override public LoginVo login(UserLoginRequestDto dto) { //1. 根据code 调用api 获取 openid ，由于很多情况要调用api，所以 封装 出去！！！ String openId = wechatService.getOpenId(dto.getCode()); 此时，因为其他功能会调用 根据code 调用api 获取 openid 这个功能，所以封装出去。 12345678910111213141516171819public interface WechatService { /** * 获取openID * @param code 前端传过来的凭证 * @return */ public String getOpenId(String code); /** * 获取手机号 * @param phoneCode * @return */ public String getPhone(String phoneCode); } 12345678910111213141516171819202122232425262728293031@Service@Slf4jpublic class WechatServiceImpl implements WechatService { // 登录 private static final String REQUEST_URL = &quot;https://api.weixin.qq.com/sns/jscode2session?grant_type=authorization_code&quot;; // 获取token private static final String TOKEN_URL = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&quot;; // 获取手机号 private static final String PHONE_REQUEST_URL = &quot;https://api.weixin.qq.com/wxa/business/getuserphonenumber?access_token=&quot;; @Value(&quot;${zzyl.wechat.appId}&quot;) private String appId; @Value(&quot;${zzyl.wechat.appSecret}&quot;) private String secret; /** * 获取openID * * @param code * @return */ @Override public String getOpenId(String code) { //使用糊涂工具 Map&lt;String,Object&gt; requestParamMap = getAppConfig();//封装结束,这个封装了前两项 requestParamMap.put(&quot;js_code&quot;, code);//继续封装进去code 封装依照下面图片内容来自官方文档 ![image-20250212144535240](/Users/gebin/Library/Application Support/typora-user-images/image-20250212144535240.png) 123456789101112/** * 封装参数 * @return */ private Map&lt;String, Object&gt; getAppConfig() { Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); resultMap.put(&quot;appid&quot;,appId);//配置文件中有 resultMap.put(&quot;secret&quot;,secret); return resultMap; } 又因为官方返回实例是 ![image-20250212144911268](/Users/gebin/Library/Application Support/typora-user-images/image-20250212144911268.png) https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html 12345678910111213141516171819String result = HttpUtil.get(REQUEST_URL, requestParamMap);//这就是官方要求的格式 /* { result 的样子如下 -----------我要拿到里面的openid &quot;openid&quot;:&quot;xxxxxx&quot;, &quot;session_key&quot;:&quot;xxxxx&quot;, &quot;unionid&quot;:&quot;xxxxx&quot;, &quot;errcode&quot;:0, &quot;errmsg&quot;:&quot;xxxxx&quot; }*/ //字符串转成 json JSONObject jsonObject = JSONUtil.parseObj(result);//JSONObject 本质就是一个增强的map，所以当成map用 //判断接口是否请求成功 if (ObjectUtil.isNotEmpty(jsonObject.getInt(&quot;errcode&quot;))){ throw new BaseException(jsonObject.getStr(&quot;errmsg&quot;)); } return jsonObject.getStr(&quot;openid&quot;); } 属于 上面的 getOpenId 这个方法 获取openId需要的参数 ![image-20250212155044000](/Users/gebin/Library/Application Support/typora-user-images/image-20250212155044000.png) 它需要调用的是下面这张图的接口 ![image-20250212155616890](/Users/gebin/Library/Application Support/typora-user-images/image-20250212155616890.png) 12345678910111213141516171819/** * 获取手机号 * https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-info/phone-number/getPhoneNumber.html * @param phoneCode * @return */ @Override public String getPhone(String phoneCode) { //此处要封装一个token方法 String token = getToken();//拿到了token String url = PHONE_REQUEST_URL + token;//作为一个url //最后把code封装进去 Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(&quot;code&quot;,phoneCode);//如下图，除了拼接一个还需要code参数 //根据开发文档进行调用 String result = HttpUtil.post(url, JSONUtil.toJsonStr(param)); ![image-20250212160748296](/Users/gebin/Library/Application Support/typora-user-images/image-20250212160748296.png) 因为非body参数，所以要拼接，String url = PHONE_REQUEST_URL + token;//作为一个url进行传递 123456789101112131415161718192021222324252627282930 //字符串转成 json JSONObject jsonObject = JSONUtil.parseObj(result);//JSONObject 本质就是一个增强的map，所以当成map用 //判断接口是否请求成功 if (jsonObject.getInt(&quot;errcode&quot;) != 0){ //不等于0 代表成功 throw new BaseException(jsonObject.getStr(&quot;errmsg&quot;)); } return jsonObject.getJSONObject(&quot;phone_info&quot;).getStr(&quot;phoneNumber&quot;); } public String getToken(){ Map&lt;String, Object&gt; map = getAppConfig();//之前封装的 String result = HttpUtil.get(TOKEN_URL, map);//使用 HttpUtil.get 方法发送 HTTP GET 请求到微信服务器。 //字符串转成 json JSONObject jsonObject = JSONUtil.parseObj(result);//JSONObject 本质就是一个增强的map，所以当成map用,方便一会拿里面需要的东西 //判断接口是否请求成功 if (ObjectUtil.isNotEmpty(jsonObject.getInt(&quot;errcode&quot;))){ throw new BaseException(jsonObject.getStr(&quot;errmsg&quot;)); }// 返回实例// {// &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,// &quot;expires_in&quot;:7200// } return jsonObject.getStr(&quot;access_token&quot;);//拿到里面的access_token的值 } 微信登录总结 解释： 首先，前端调用了login 方法，会给我们返回三个参数。我们端接受到三个参数之后，首先使用了登录接口来拿到openid这个微信的专属认证标志，代码中我们用getOpenId封装来实现的。 拿到openid之后来查询客户的信息，判断是否为空，如果为空就说明第一次登录，我们需要创建一个新的用户然后赋值新的openid； 然后是获取手机号的方法，在代码中我们是通过 wechatService.getPhone(dto.getPhoneCode()) 封装到wechatService实现，拿到手机号。 拦截器前置知识 ![image-20250213115137206](/Users/gebin/Library/Application Support/typora-user-images/image-20250213115137206.png) ==每个请求==都是一个单独的线程，李四过来也是单独开始一个线程，都会开辟一块新空间！ ![image-20250213115809329](/Users/gebin/Library/Application Support/typora-user-images/image-20250213115809329.png) 代码实现必须实现 ==HandlerInterceptor==，会实现preHandle，afterCompletion。一般在preHandle 中会有 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 小程序端token校验 * 统一对请求的合法性进行校验，需要进行2个方面的校验， * 一、请求头中是否携带了authorization * 二、请求头中是否存在userId，如果不存在则说明是非法请求，响应401状态码 * 如果是合法请求，将userId存储到ThreadLocal中 */@Slf4j@Component@EnableConfigurationProperties(JwtTokenManagerProperties.class)public class UserInterceptor implements HandlerInterceptor { @Autowired private JwtTokenManagerProperties jwtTokenManagerProperties; //所有的校验逻辑都是在 前置 里面写的 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //获取token String token = request.getHeader(SecurityConstant.USER_TOKEN); //判断是否为空 if (ObjectUtil.isEmpty(token)){ throw new BaseException(&quot;小程序&quot;,&quot;401&quot;,null,&quot;小程序token失效，请重新登录&quot;); } //解析token Map&lt;String,Object&gt; claims = JwtUtil.parseJWT(jwtTokenManagerProperties.getBase64EncodedSecretKey(), token); //看一下当前的claims里面有没有数据 if (ObjectUtil.isEmpty(claims)){ throw new BaseException(&quot;小程序&quot;,&quot;401&quot;,null,&quot;小程序token失效，请重新登录&quot;); } //获取数据，拿到用户id Long userId = MapUtil.get(claims, Constants.JWT_USERID, Long.class); if (ObjectUtil.isEmpty(userId)){ throw new BaseException(&quot;小程序&quot;,&quot;401&quot;,null,&quot;小程序token失效，请重新登录&quot;); } //存储到threadlocal中 UserThreadLocal.set(userId); return true; } //之后就直接清除 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { UserThreadLocal.remove(); }} 拦截器注册12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * webMvc高级配置 */@Configuration@ComponentScan(&quot;springfox.documentation.swagger.web&quot;)public class WebMvcConfig implements WebMvcConfigurer { @Autowired UserTokenIntercept userTokenIntercept; @Autowired UserInterceptor userInterceptor;//小程序的拦截 //拦截的时候过滤掉swagger相关路径和登录相关接口 private static final String[] EXCLUDE_PATH_PATTERNS = new String[]{&quot;/swagger-ui.html&quot;, &quot;/webjars/**&quot;, &quot;/swagger-resources&quot;, &quot;/v2/api-docs&quot;, // 登录接口 &quot;/customer/user/login&quot;, // 房型列表接口 &quot;/customer/roomTypes&quot;, &quot;/customer/orders/project/**&quot;, &quot;/user/refresh/**&quot;}; /** * 拦截器 */ @Override public void addInterceptors(InterceptorRegistry registry) { //userToken拦截 registry.addInterceptor(userTokenIntercept).excludePathPatterns(ADMIN_EXCLUDE_PATH_PATTERNS); //小程序端接口鉴权拦截器 registry.addInterceptor(userInterceptor).excludePathPatterns(EXCLUDE_PATH_PATTERNS).addPathPatterns(&quot;/customer/**&quot;);//只拦截这路径 } //拦截的时候过滤掉swagger相关路径和登录相关接口 private static final String[] ADMIN_EXCLUDE_PATH_PATTERNS = new String[]{&quot;/swagger-ui.html&quot;, &quot;/webjars/**&quot;, &quot;/swagger-resources&quot;, &quot;/v2/api-docs&quot;, &quot;/customer/**&quot;, &quot;/security/**&quot;, &quot;/common/**&quot;, &quot;/user/refresh/**&quot;}; /** * 资源路径 映射 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //支持webjars registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;); //支持swagger registry.addResourceHandler(&quot;swagger-ui.html&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); //支持小刀 registry.addResourceHandler(&quot;doc.html&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); } public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;; @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() { return builder -&gt; { // 序列化 builder.serializerByType(Long.class, ToStringSerializer.instance); builder.serializerByType(BigInteger.class, ToStringSerializer.instance); builder.serializerByType(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))); builder.serializerByType(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))); builder.serializerByType(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); // 反序列化 builder.deserializerByType(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))); builder.deserializerByType(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))); builder.deserializerByType(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); }; }} 其中本次写的拦截器代码 先注册 12@AutowiredUserInterceptor userInterceptor;//小程序的拦截 12//小程序端接口鉴权拦截器registry.addInterceptor(userInterceptor).excludePathPatterns(EXCLUDE_PATH_PATTERNS).addPathPatterns(&quot;/customer/**&quot;);//只拦截这路径","link":"/2025/02/15/%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"title":"权限管理模块开发","text":"权限认证权限认证基础什么是权限认证？ 就是不同的角色能访问到的页面是不一样的 比如用超级管理员的账户登录的页面如下 可以看出，他有全部的权限。 护理员登录时： 财务登录时： ![image-20250214170854273](/Users/gebin/Library/Application Support/typora-user-images/image-20250214170854273.png) 可以看出，不同的角色分配了不同的权限，这就是RBAC模型（Role Based Access Control）。 完成的效果图 操作的表 红色的表为中间表，一共是8张表，其中最重要的是左半边5张。 部门管理部门列表接口接口地址:/dept/list 请求方式:POST 请求示例: 12345{ &quot;parentDeptNo&quot;: &quot;&quot;, //父部门编号 &quot;dataState&quot;: &quot;&quot;, //状态 &quot;deptName&quot;: &quot;&quot; //部门名称} 响应示例: 123456789101112131415161718192021222324252627282930313233343536373839{ &quot;code&quot;: 200, &quot;msg&quot;: &quot;操作成功&quot;, &quot;data&quot;: [ { &quot;id&quot;: &quot;1671445634122588250&quot;, &quot;createTime&quot;: &quot;2023-07-09 16:00:13&quot;, &quot;createDay&quot;: &quot;2023-07-09&quot;, &quot;updateTime&quot;: &quot;2023-08-25 20:21:56&quot;, &quot;createBy&quot;: &quot;1&quot;, &quot;updateBy&quot;: &quot;1671403256519078006&quot;, &quot;dataState&quot;: &quot;0&quot;, &quot;remark&quot;: &quot;大沙发的&quot;, &quot;parentDeptNo&quot;: &quot;100001000000000&quot;, &quot;deptNo&quot;: &quot;100001030000000&quot;, &quot;deptName&quot;: &quot;静测试部&quot;, &quot;sortNo&quot;: 0, &quot;level&quot;: 4 }, { &quot;id&quot;: &quot;1671445634122588247&quot;, &quot;createTime&quot;: &quot;2023-07-07 18:18:59&quot;, &quot;createDay&quot;: &quot;2023-07-07&quot;, &quot;updateTime&quot;: &quot;2023-07-28 17:19:19&quot;, &quot;createBy&quot;: &quot;1671403256519078006&quot;, &quot;updateBy&quot;: &quot;1671403256519078006&quot;, &quot;dataState&quot;: &quot;0&quot;, &quot;remark&quot;: &quot;&quot;, &quot;parentDeptNo&quot;: &quot;100001000000000&quot;, &quot;deptNo&quot;: &quot;100001029000000&quot;, &quot;deptName&quot;: &quot;大管家&quot;, &quot;sortNo&quot;: 0, &quot;leaderId&quot;: &quot;1671403256519078076&quot;, &quot;leaderName&quot;: &quot;你是是&quot;, &quot;level&quot;: 4 } ], &quot;operationTime&quot;: &quot;2023-08-27 11:25:01&quot;} 控制层 1234567891011121314151617181920@Slf4j@Api(tags = &quot;部门管理&quot;)@RestController@RequestMapping(&quot;dept&quot;)public class DeptController { @Autowired private DeptService deptService; @PostMapping(&quot;/list&quot;) @ApiImplicitParam(name = &quot;deptDto&quot;,value = &quot;部门DTO对象&quot;,required = true,dataType = &quot;DeptDto&quot;) @ApiOperationSupport( includeParameters = {&quot;deptDto.dataState&quot;,&quot;deptDto.deptName&quot;,&quot;deptDto.parentDeptNo&quot;} ) public ResponseResult list(@RequestBody DeptDto deptDto){//因为是post请求，所以要用对象的方式进行接受 List&lt;DeptVo&gt; deptVoList = deptService.getList(deptDto); return ResponseResult.success(deptVoList); } 服务接口 12345678910111213/** * 部门表服务类 */public interface DeptService { /** * 条件查询部门列表 * @param deptDto * @return */ List&lt;DeptVo&gt; getList(DeptDto deptDto);} 服务实现类 1234567891011121314151617181920/** * 部门表服务实现类 */@Servicepublic class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; /** * 条件查询部门列表 * * @param deptDto * @return */ @Override public List&lt;DeptVo&gt; getList(DeptDto deptDto) { return deptMapper.getList(deptDto); }} 1234@Mapperpublic interface DeptMapper { List&lt;DeptVo&gt; getList(DeptDto deptDto);} Sql 分析 12345678select sd.*, su.real_name from sys_dept sd left join sys_user su on sd.leader_id = su.id; Mapper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;mapper namespace=&quot;com.zzyl.mapper.DeptMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.zzyl.entity.Dept&quot;&gt; &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;parent_dept_no&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;parentDeptNo&quot;/&gt; &lt;result column=&quot;dept_no&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deptNo&quot;/&gt; &lt;result column=&quot;dept_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deptName&quot;/&gt; &lt;result column=&quot;sort_no&quot; jdbcType=&quot;INTEGER&quot; property=&quot;sortNo&quot;/&gt; &lt;result column=&quot;data_state&quot; jdbcType=&quot;CHAR&quot; property=&quot;dataState&quot;/&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot;/&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot;/&gt; &lt;result column=&quot;create_by&quot; jdbcType=&quot;BIGINT&quot; property=&quot;createBy&quot;/&gt; &lt;result column=&quot;update_by&quot; jdbcType=&quot;BIGINT&quot; property=&quot;updateBy&quot;/&gt; &lt;result column=&quot;leader_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;leaderId&quot;/&gt; &lt;result column=&quot;leader_name&quot; jdbcType=&quot;BIGINT&quot; property=&quot;leaderName&quot;/&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;BaseResultVoMap&quot; type=&quot;com.zzyl.vo.DeptVo&quot;&gt; &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;parent_dept_no&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;parentDeptNo&quot;/&gt; &lt;result column=&quot;dept_no&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deptNo&quot;/&gt; &lt;result column=&quot;dept_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deptName&quot;/&gt; &lt;result column=&quot;sort_no&quot; jdbcType=&quot;INTEGER&quot; property=&quot;sortNo&quot;/&gt; &lt;result column=&quot;data_state&quot; jdbcType=&quot;CHAR&quot; property=&quot;dataState&quot;/&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot;/&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot;/&gt; &lt;result column=&quot;create_by&quot; jdbcType=&quot;BIGINT&quot; property=&quot;createBy&quot;/&gt; &lt;result column=&quot;update_by&quot; jdbcType=&quot;BIGINT&quot; property=&quot;updateBy&quot;/&gt; &lt;result column=&quot;leader_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;leaderId&quot;/&gt; &lt;result column=&quot;role_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;roleId&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getList&quot; resultType=&quot;com.zzyl.vo.DeptVo&quot;&gt; select d.id, d.parent_dept_no, d.dept_no, d.dept_name, d.sort_no, d.data_state, d.create_time, d.update_time, d.create_by, d.update_by, d.remark, d.leader_id , u.real_name as leader_name,DATE_FORMAT(d.create_time,'%Y-%m-%d') as create_day from sys_dept d left join sys_user u on u.id = leader_id &lt;where&gt; &lt;if test=&quot;deptName!=null and deptName!=''&quot;&gt; and d.dept_name like concat('%',#{deptName},'%') &lt;/if&gt; &lt;if test=&quot;parentDeptNo!=null and parentDeptNo!=''&quot;&gt; and d.parent_dept_no like concat(#{parentDeptNo},'%') &lt;/if&gt; &lt;if test=&quot;dataState!=null and dataState!=''&quot;&gt; and d.data_state=#{dataState} &lt;/if&gt; &lt;/where&gt; order by d.sort_no asc, d.create_time desc &lt;/select&gt;&lt;/mapper&gt; 其中重点的就是 DATE_FORMAT(d.create_time,’%Y-%m-%d’) 因为前端页面上不需要展示和具体的是十分秒，所以要格式化一下。 u.id = leader_id 因为展示的时候有部门负责人所以要关联一下表。 部门树形结构接口由于是初始化部门的树形结构，这个接口需要在部门中去定义 接口地址:/dept/tree 请求方式:POST 请求示例: 无 响应示例: 1234567891011121314151617181920212223242526272829303132{ &quot;code&quot;: 200, &quot;msg&quot;: &quot;操作成功&quot;, &quot;data&quot;: { &quot;items&quot;: [ { &quot;id&quot;: &quot;100001000000000&quot;, &quot;label&quot;: &quot;智慧养老院&quot;, &quot;children&quot;: [ { &quot;id&quot;: &quot;100001001000000&quot;, &quot;label&quot;: &quot;院长办公室&quot; }, { &quot;id&quot;: &quot;100001002000000&quot;, &quot;label&quot;: &quot;财务部&quot;, &quot;children&quot;: [ { &quot;id&quot;: &quot;100001002001000&quot;, &quot;label&quot;: &quot;会计组&quot; }, { &quot;id&quot;: &quot;100001002002000&quot;, &quot;label&quot;: &quot;结算组&quot; } ] } ] } ] }} 得用递归的方法 ： 分析 items 是一个集合，集合中又又对象，对象中又有另外一个集合。 所以说在设计返回值的时候。 12345678910public class TreeVo implements Serializable { @ApiModelProperty(value = &quot;tree数据&quot;) private List&lt;TreeItemVo&gt; items; @Builder public TreeVo(List&lt;TreeItemVo&gt; items) { this.items = items; }} 12345678910public class TreeItemVo implements Serializable { @ApiModelProperty(value = &quot;节点ID&quot;) public String id; @ApiModelProperty(value = &quot;显示内容&quot;) public String label; @ApiModelProperty(value = &quot;显示内容&quot;) public List&lt;TreeItemVo&gt; children = new ArrayList&lt;&gt;();//又包含自己 集合之中装的又是它本身。 123456@PostMapping(&quot;/tree&quot;)public ResponseResult&lt;TreeVo&gt; deptTree(){ TreeVo treeVo = deptService.deptTree(); return ResponseResult.success(treeVo);} 12345/** * 查询部门树形结构 * @return */ TreeVo deptTree(); 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 查询部门树形结构 * * @return */ @Override public TreeVo deptTree() { //先拿到根部门下的所有子部门 String rootDeptParentId = SuperConstant.ROOT_DEPT_PARENT_ID; //构建一下 DeptDto deptDto = DeptDto.builder().parentDeptNo(NoProcessing.processString(rootDeptParentId)).build();//把里面的parentDeptNo赋值 //所有数据 List&lt;DeptVo&gt; deptVoList = getList(deptDto);//这就是所有数据 List&lt;TreeItemVo&gt; items = new ArrayList&lt;&gt;();//待组装的 //从所有数据deptVoList 中 拿出树形结构封装到items 中去 //先查找第一个节点 相当于 从所有节点deptVoList中拿到每一个元素 d也就是所有部门，找这个部门父是000号的也就是根拿第一个 DeptVo rootDept = deptVoList.stream() .filter(d -&gt; d.getParentDeptNo() .equals(rootDeptParentId)).collect(Collectors.toList()).get(0);//这个也即是我上图中所框选的那边分，也就是真正的根 //递归的处理问题 recursionTreeItem(items,rootDept,deptVoList); return TreeVo.builder().items(items).build(); } /** * 递归 * @param items * @param rootDept * @param deptVoList */ private void recursionTreeItem(List&lt;TreeItemVo&gt; items, DeptVo rootDept, List&lt;DeptVo&gt; deptVoList) { TreeItemVo treeItemVo = TreeItemVo.builder() .id(rootDept.getDeptNo())//当前的部门编号 .label(rootDept.getDeptName()).build();//部门的名称 //找子级，依照 以 rootDept 为根的子节点 List&lt;DeptVo&gt; childrenList = deptVoList.stream() .filter(d -&gt; d.getParentDeptNo() .equals(rootDept.getDeptNo())).collect(Collectors.toList()); //如果不为空就是有子，有可能到这是最后叶子节点了 if (!EmptyUtil.isNullOrEmpty(childrenList)){ List&lt;TreeItemVo&gt; listChildrenList = new ArrayList&lt;&gt;();//待组装 //遍历一下 childrenList.forEach( dept -&gt; { recursionTreeItem(listChildrenList,dept,deptVoList); }); treeItemVo.setChildren(listChildrenList); } items.add(treeItemVo); }","link":"/2025/02/18/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[],"pages":[]}