{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/1985/10/26/hello-world/"},{"title":"基础项目开发","text":"养老项目一、基础数据开发前瞻知识点 为什么要区分 DTO 和 VO 对象？ 因为有些情况不想传完整的数据进去，vo相当于能过滤一遍，只发送必要的数据。 护理接口分页查询数据创建一个dto对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 护理项目数据传输对象 */@Datapublic class NursingProjectDto extends BaseDto { /** * 名称 */ @ApiModelProperty(value = &quot;名称&quot;) private String name; /** * 排序号 */ @ApiModelProperty(value = &quot;排序号&quot;) private Integer orderNo; /** * 单位 */ @ApiModelProperty(value = &quot;单位&quot;) private String unit; /** * 价格 */ @ApiModelProperty(value = &quot;价格&quot;) private BigDecimal price; /** * 图片 */ @ApiModelProperty(value = &quot;图片&quot;) private String image; /** * 护理要求 */ @ApiModelProperty(value = &quot;护理要求&quot;) private String nursingRequirement; /** * 状态（0：禁用，1：启用） */ @ApiModelProperty(value = &quot;状态（0：禁用，1：启用）&quot;) private Integer status;} Controll12345678910111213141516171819202122232425/** * @author geb * @create 2025-01-27-10:59 AM */@RestController@RequestMapping(&quot;/nursing_project&quot;)public class NursingProjectController extends BaseController{ @Autowired private NursingProjectService nursingProjectService; @GetMapping public ResponseResult getByPage(@RequestParam(value = &quot;name&quot;, required = false) String name, @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;10&quot;) Integer pageSize, @RequestParam(value = &quot;status&quot;,required = false) Integer status) { PageResponse&lt;NursingProjectVo&gt; page = nursingProjectService.getPage(name, pageNum, pageSize, status); return success(page); }} Service123456789/** * @author geb * @create 2025-02-05-1:34 PM */public interface NursingProjectService { public PageResponse&lt;NursingProjectVo&gt; getPage(String name,Integer pageNum,Integer pageSize,Integer state);} ServiceImpl1234567891011121314151617181920212223/** * @author geb * @create 2025-02-05-1:40 PM */@Servicepublic class NursingProjectServiceImpl implements NursingProjectService { @Autowired private NursingProjectMapper nursingProjectMapper; @Override public PageResponse&lt;NursingProjectVo&gt; getPage(String name, Integer pageNum, Integer pageSize, Integer status) { //分页 PageHelper.startPage(pageNum,pageSize); Page&lt;NursingProjectVo&gt; projectVoPage = nursingProjectMapper.getByPage(name, pageNum, pageSize, status); return PageResponse.of(projectVoPage,NursingProjectVo.class); }} Mapper123456789@Mapperpublic interface NursingProjectMapper { public Page&lt;NursingProjectVo&gt; getByPage( String name, Integer pageNum, Integer pageSize, Integer status );} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.zzyl.mapper.NursingProjectMapper&quot;&gt; &lt;resultMap id=&quot;nursingProjectResultMap&quot; type=&quot;com.zzyl.vo.NursingProjectVo&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;order_no&quot; property=&quot;orderNo&quot;/&gt; &lt;result column=&quot;unit&quot; property=&quot;unit&quot;/&gt; &lt;result column=&quot;price&quot; property=&quot;price&quot;/&gt; &lt;result column=&quot;image&quot; property=&quot;image&quot;/&gt; &lt;result column=&quot;nursing_requirement&quot; property=&quot;nursingRequirement&quot;/&gt; &lt;result column=&quot;status&quot; property=&quot;status&quot;/&gt; &lt;result column=&quot;create_by&quot; property=&quot;createBy&quot;/&gt; &lt;result column=&quot;update_by&quot; property=&quot;updateBy&quot;/&gt; &lt;result column=&quot;remark&quot; property=&quot;remark&quot;/&gt; &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot;/&gt; &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot;/&gt; &lt;result column=&quot;creator&quot; property=&quot;creator&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getByPage&quot; resultMap=&quot;nursingProjectResultMap&quot;&gt; select np.id, np.name, np.order_no, np.unit, np.price, np.image, np.nursing_requirement, np.status, np.create_by, np.update_by, np.remark, np.create_time, np.update_time, su.real_name from nursing_project np left join sys_user su on np.create_by=su.id &lt;where&gt; &lt;if test=&quot;name != null and name != ''&quot;&gt; and name like concat('%',#{name},'%') &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; and status = #{status} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; ![image-20250206114812693](/Users/gebin/Library/Application Support/typora-user-images/image-20250206114812693.png) 新增Controll123456789101112/** * 添加护理项目 * @param nursingProjectDto * @return */ @PostMapping public ResponseResult add(@RequestBody NursingProjectDto nursingProjectDto){ nursingProjectService.add(nursingProjectDto); return success();} Service12345/** * 添加护理项目 * @param nursingProjectDto */ void add(NursingProjectDto nursingProjectDto); ServiceImpl12345678910111213/** * 添加护理项目 * * @param nursingProjectDto */ @Override public void add(NursingProjectDto nursingProjectDto) { //对象的转换 把当前nursingProjectDto 里面的所有属性都拷贝到NursingProject 中，因为nursingProjectDto 中的属性不全 NursingProject nursingProject = BeanUtil.copyProperties(nursingProjectDto, NursingProject.class); //调用mapper nursingProjectMapper.insert(nursingProject); } Mapper1void insert(NursingProject nursingProject); 123456&lt;insert id=&quot;insert&quot;&gt; insert into nursing_project (name, order_no, unit, price, image, nursing_requirement, status, create_by, update_by, remark, create_time, update_time) values (#{name}, #{orderNo}, #{unit}, #{price}, #{image}, #{nursingRequirement}, #{status}, #{createBy}, #{updateBy}, #{remark}, #{createTime}, #{updateTime})&lt;/insert&gt; ![image-20250206170214310](/Users/gebin/Library/Application Support/typora-user-images/image-20250206170214310.png) 编辑回显数据– 根据ID查询数据Controll1234567@GetMapping(&quot;/{id}&quot;) public ResponseResult getById(@PathVariable(&quot;id&quot;) Long id){ NursingProjectVo nursingProjectVo = nursingProjectService.getById(id); return success(nursingProjectVo);} Service123456 /** * 根据id 查询护理项目 * @param id * @return */NursingProjectVo getById(Long id); ServiceImpl12345678910/** * 根据id 查询护理项目 * * @param id * @return */ @Overridepublic NursingProjectVo getById(Long id) { return nursingProjectMapper.getById(id);} Mapper1NursingProjectVo getById(Long id); 12345&lt;select id=&quot;getById&quot; resultMap=&quot;nursingProjectResultMap&quot;&gt; select * from nursing_project where id = #{id}&lt;/select&gt; ![image-20250206175745552](/Users/gebin/Library/Application Support/typora-user-images/image-20250206175745552.png) 此时，回显数据成功 更新数据Controll12345@PutMapping public ResponseResult update(@RequestBody NursingProjectDto nursingProjectDto){ nursingProjectService.update(nursingProjectDto); return success(); } Service12345/** * 修改护理项目 * @param nursingProjectDto */ void update(NursingProjectDto nursingProjectDto); ServiceImpl1234567891011/** * 修改护理项目 * * @param nursingProjectDto */ @Override public void update(NursingProjectDto nursingProjectDto) { NursingProject nursingProject = new NursingProject(); BeanUtils.copyProperties(nursingProjectDto, nursingProject); nursingProjectMapper.update(nursingProject); } Mapper1void update(NursingProject nursingProject); 1234567891011121314&lt;update id=&quot;update&quot;&gt; update nursing_project set name = #{name}, order_no = #{orderNo}, unit = #{unit}, price = #{price}, image = #{image}, nursing_requirement = #{nursingRequirement}, status = #{status}, update_by = #{updateBy}, remark = #{remark}, update_time = #{updateTime} where id = #{id} &lt;/update&gt; 二、微信登录Controll12345678910111213141516@RestController@RequestMapping(&quot;/customer/user&quot;)@Api(tags = &quot;小程序登录&quot;)public class CustomerUserController extends BaseController { @Autowired private MemberService memberService; @PostMapping(&quot;/login&quot;) @ApiOperation(&quot;登录&quot;) public ResponseResult&lt;LoginVo&gt; login(@RequestBody UserLoginRequestDto dto){ LoginVo loginVo = memberService.login(dto); return ResponseResult.success(loginVo); }} Service123456789101112/** * 用户管理 */public interface MemberService { /** * 登录方法 * @param dto * @return */ LoginVo login(UserLoginRequestDto dto);} ServiceImpl获取手机号1234567891011121314151617181920212223242526272829303132333435363738394041/** * 用户管理 */@Slf4j@Servicepublic class MemberServiceImpl implements MemberService { @Autowired private WechatService wechatService; @Autowired private MemberMapper memberMapper; @Autowired private JwtTokenManagerProperties jwtTokenManagerProperties; static ArrayList DEFAULT_NICKNAME_PREFIX = Lists.newArrayList( &quot;生活更美好&quot;, &quot;大桔大利&quot;, &quot;日富一日&quot;, &quot;好柿开花&quot;, &quot;柿柿如意&quot;, &quot;一椰暴富&quot;, &quot;大柚所为&quot;, &quot;杨梅吐气&quot;, &quot;天生荔枝&quot; ); /** * 登录方法 * * @param dto * @return */ @Override public LoginVo login(UserLoginRequestDto dto) { //1. 根据code 调用api 获取 openid ，由于很多情况要调用api，所以 封装 出去！！！ String openId = wechatService.getOpenId(dto.getCode()); 此时，因为其他功能会调用 根据code 调用api 获取 openid 这个功能，所以封装出去。 12345678910111213141516171819public interface WechatService { /** * 获取openID * @param code 前端传过来的凭证 * @return */ public String getOpenId(String code); /** * 获取手机号 * @param phoneCode * @return */ public String getPhone(String phoneCode); } 12345678910111213141516171819202122232425262728293031@Service@Slf4jpublic class WechatServiceImpl implements WechatService { // 登录 private static final String REQUEST_URL = &quot;https://api.weixin.qq.com/sns/jscode2session?grant_type=authorization_code&quot;; // 获取token private static final String TOKEN_URL = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&quot;; // 获取手机号 private static final String PHONE_REQUEST_URL = &quot;https://api.weixin.qq.com/wxa/business/getuserphonenumber?access_token=&quot;; @Value(&quot;${zzyl.wechat.appId}&quot;) private String appId; @Value(&quot;${zzyl.wechat.appSecret}&quot;) private String secret; /** * 获取openID * * @param code * @return */ @Override public String getOpenId(String code) { //使用糊涂工具 Map&lt;String,Object&gt; requestParamMap = getAppConfig();//封装结束,这个封装了前两项 requestParamMap.put(&quot;js_code&quot;, code);//继续封装进去code 封装依照下面图片内容来自官方文档 ![image-20250212144535240](/Users/gebin/Library/Application Support/typora-user-images/image-20250212144535240.png) 123456789101112/** * 封装参数 * @return */ private Map&lt;String, Object&gt; getAppConfig() { Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); resultMap.put(&quot;appid&quot;,appId);//配置文件中有 resultMap.put(&quot;secret&quot;,secret); return resultMap; } 又因为官方返回实例是 ![image-20250212144911268](/Users/gebin/Library/Application Support/typora-user-images/image-20250212144911268.png) https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html 12345678910111213141516171819String result = HttpUtil.get(REQUEST_URL, requestParamMap);//这就是官方要求的格式 /* { result 的样子如下 -----------我要拿到里面的openid &quot;openid&quot;:&quot;xxxxxx&quot;, &quot;session_key&quot;:&quot;xxxxx&quot;, &quot;unionid&quot;:&quot;xxxxx&quot;, &quot;errcode&quot;:0, &quot;errmsg&quot;:&quot;xxxxx&quot; }*/ //字符串转成 json JSONObject jsonObject = JSONUtil.parseObj(result);//JSONObject 本质就是一个增强的map，所以当成map用 //判断接口是否请求成功 if (ObjectUtil.isNotEmpty(jsonObject.getInt(&quot;errcode&quot;))){ throw new BaseException(jsonObject.getStr(&quot;errmsg&quot;)); } return jsonObject.getStr(&quot;openid&quot;); } 属于 上面的 getOpenId 这个方法 获取openId需要的参数 ![image-20250212155044000](/Users/gebin/Library/Application Support/typora-user-images/image-20250212155044000.png) 它需要调用的是下面这张图的接口 ![image-20250212155616890](/Users/gebin/Library/Application Support/typora-user-images/image-20250212155616890.png) 12345678910111213141516171819/** * 获取手机号 * https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-info/phone-number/getPhoneNumber.html * @param phoneCode * @return */ @Override public String getPhone(String phoneCode) { //此处要封装一个token方法 String token = getToken();//拿到了token String url = PHONE_REQUEST_URL + token;//作为一个url //最后把code封装进去 Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(&quot;code&quot;,phoneCode);//如下图，除了拼接一个还需要code参数 //根据开发文档进行调用 String result = HttpUtil.post(url, JSONUtil.toJsonStr(param)); ![image-20250212160748296](/Users/gebin/Library/Application Support/typora-user-images/image-20250212160748296.png) 因为非body参数，所以要拼接，String url = PHONE_REQUEST_URL + token;//作为一个url进行传递 123456789101112131415161718192021222324252627282930 //字符串转成 json JSONObject jsonObject = JSONUtil.parseObj(result);//JSONObject 本质就是一个增强的map，所以当成map用 //判断接口是否请求成功 if (jsonObject.getInt(&quot;errcode&quot;) != 0){ //不等于0 代表成功 throw new BaseException(jsonObject.getStr(&quot;errmsg&quot;)); } return jsonObject.getJSONObject(&quot;phone_info&quot;).getStr(&quot;phoneNumber&quot;); } public String getToken(){ Map&lt;String, Object&gt; map = getAppConfig();//之前封装的 String result = HttpUtil.get(TOKEN_URL, map);//使用 HttpUtil.get 方法发送 HTTP GET 请求到微信服务器。 //字符串转成 json JSONObject jsonObject = JSONUtil.parseObj(result);//JSONObject 本质就是一个增强的map，所以当成map用,方便一会拿里面需要的东西 //判断接口是否请求成功 if (ObjectUtil.isNotEmpty(jsonObject.getInt(&quot;errcode&quot;))){ throw new BaseException(jsonObject.getStr(&quot;errmsg&quot;)); }// 返回实例// {// &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,// &quot;expires_in&quot;:7200// } return jsonObject.getStr(&quot;access_token&quot;);//拿到里面的access_token的值 } 微信登录总结 解释： 首先，前端调用了login 方法，会给我们返回三个参数。我们端接受到三个参数之后，首先使用了登录接口来拿到openid这个微信的专属认证标志，代码中我们用getOpenId封装来实现的。 拿到openid之后来查询客户的信息，判断是否为空，如果为空就说明第一次登录，我们需要创建一个新的用户然后赋值新的openid； 然后是获取手机号的方法，在代码中我们是通过 wechatService.getPhone(dto.getPhoneCode()) 封装到wechatService实现，拿到手机号。 拦截器前置知识 ![image-20250213115137206](/Users/gebin/Library/Application Support/typora-user-images/image-20250213115137206.png) ==每个请求==都是一个单独的线程，李四过来也是单独开始一个线程，都会开辟一块新空间！ ![image-20250213115809329](/Users/gebin/Library/Application Support/typora-user-images/image-20250213115809329.png) 代码实现必须实现 ==HandlerInterceptor==，会实现preHandle，afterCompletion。一般在preHandle 中会有 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 小程序端token校验 * 统一对请求的合法性进行校验，需要进行2个方面的校验， * 一、请求头中是否携带了authorization * 二、请求头中是否存在userId，如果不存在则说明是非法请求，响应401状态码 * 如果是合法请求，将userId存储到ThreadLocal中 */@Slf4j@Component@EnableConfigurationProperties(JwtTokenManagerProperties.class)public class UserInterceptor implements HandlerInterceptor { @Autowired private JwtTokenManagerProperties jwtTokenManagerProperties; //所有的校验逻辑都是在 前置 里面写的 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //获取token String token = request.getHeader(SecurityConstant.USER_TOKEN); //判断是否为空 if (ObjectUtil.isEmpty(token)){ throw new BaseException(&quot;小程序&quot;,&quot;401&quot;,null,&quot;小程序token失效，请重新登录&quot;); } //解析token Map&lt;String,Object&gt; claims = JwtUtil.parseJWT(jwtTokenManagerProperties.getBase64EncodedSecretKey(), token); //看一下当前的claims里面有没有数据 if (ObjectUtil.isEmpty(claims)){ throw new BaseException(&quot;小程序&quot;,&quot;401&quot;,null,&quot;小程序token失效，请重新登录&quot;); } //获取数据，拿到用户id Long userId = MapUtil.get(claims, Constants.JWT_USERID, Long.class); if (ObjectUtil.isEmpty(userId)){ throw new BaseException(&quot;小程序&quot;,&quot;401&quot;,null,&quot;小程序token失效，请重新登录&quot;); } //存储到threadlocal中 UserThreadLocal.set(userId); return true; } //之后就直接清除 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { UserThreadLocal.remove(); }} 拦截器注册12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * webMvc高级配置 */@Configuration@ComponentScan(&quot;springfox.documentation.swagger.web&quot;)public class WebMvcConfig implements WebMvcConfigurer { @Autowired UserTokenIntercept userTokenIntercept; @Autowired UserInterceptor userInterceptor;//小程序的拦截 //拦截的时候过滤掉swagger相关路径和登录相关接口 private static final String[] EXCLUDE_PATH_PATTERNS = new String[]{&quot;/swagger-ui.html&quot;, &quot;/webjars/**&quot;, &quot;/swagger-resources&quot;, &quot;/v2/api-docs&quot;, // 登录接口 &quot;/customer/user/login&quot;, // 房型列表接口 &quot;/customer/roomTypes&quot;, &quot;/customer/orders/project/**&quot;, &quot;/user/refresh/**&quot;}; /** * 拦截器 */ @Override public void addInterceptors(InterceptorRegistry registry) { //userToken拦截 registry.addInterceptor(userTokenIntercept).excludePathPatterns(ADMIN_EXCLUDE_PATH_PATTERNS); //小程序端接口鉴权拦截器 registry.addInterceptor(userInterceptor).excludePathPatterns(EXCLUDE_PATH_PATTERNS).addPathPatterns(&quot;/customer/**&quot;);//只拦截这路径 } //拦截的时候过滤掉swagger相关路径和登录相关接口 private static final String[] ADMIN_EXCLUDE_PATH_PATTERNS = new String[]{&quot;/swagger-ui.html&quot;, &quot;/webjars/**&quot;, &quot;/swagger-resources&quot;, &quot;/v2/api-docs&quot;, &quot;/customer/**&quot;, &quot;/security/**&quot;, &quot;/common/**&quot;, &quot;/user/refresh/**&quot;}; /** * 资源路径 映射 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //支持webjars registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;); //支持swagger registry.addResourceHandler(&quot;swagger-ui.html&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); //支持小刀 registry.addResourceHandler(&quot;doc.html&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); } public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;; @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() { return builder -&gt; { // 序列化 builder.serializerByType(Long.class, ToStringSerializer.instance); builder.serializerByType(BigInteger.class, ToStringSerializer.instance); builder.serializerByType(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))); builder.serializerByType(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))); builder.serializerByType(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); // 反序列化 builder.deserializerByType(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))); builder.deserializerByType(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))); builder.deserializerByType(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); }; }} 其中本次写的拦截器代码 先注册 12@AutowiredUserInterceptor userInterceptor;//小程序的拦截 12//小程序端接口鉴权拦截器registry.addInterceptor(userInterceptor).excludePathPatterns(EXCLUDE_PATH_PATTERNS).addPathPatterns(&quot;/customer/**&quot;);//只拦截这路径","link":"/2025/02/15/%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"title":"权限管理模块开发","text":"权限认证权限认证基础什么是权限认证？ 就是不同的角色能访问到的页面是不一样的 比如用超级管理员的账户登录的页面如下 可以看出，他有全部的权限。 护理员登录时： 财务登录时： ![image-20250214170854273](/Users/gebin/Library/Application Support/typora-user-images/image-20250214170854273.png) 可以看出，不同的角色分配了不同的权限，这就是RBAC模型（Role Based Access Control）。 完成的效果图 操作的表 红色的表为中间表，一共是8张表，其中最重要的是左半边5张。 部门管理部门列表接口接口地址:/dept/list 请求方式:POST 请求示例: 12345{ &quot;parentDeptNo&quot;: &quot;&quot;, //父部门编号 &quot;dataState&quot;: &quot;&quot;, //状态 &quot;deptName&quot;: &quot;&quot; //部门名称} 响应示例: 123456789101112131415161718192021222324252627282930313233343536373839{ &quot;code&quot;: 200, &quot;msg&quot;: &quot;操作成功&quot;, &quot;data&quot;: [ { &quot;id&quot;: &quot;1671445634122588250&quot;, &quot;createTime&quot;: &quot;2023-07-09 16:00:13&quot;, &quot;createDay&quot;: &quot;2023-07-09&quot;, &quot;updateTime&quot;: &quot;2023-08-25 20:21:56&quot;, &quot;createBy&quot;: &quot;1&quot;, &quot;updateBy&quot;: &quot;1671403256519078006&quot;, &quot;dataState&quot;: &quot;0&quot;, &quot;remark&quot;: &quot;大沙发的&quot;, &quot;parentDeptNo&quot;: &quot;100001000000000&quot;, &quot;deptNo&quot;: &quot;100001030000000&quot;, &quot;deptName&quot;: &quot;静测试部&quot;, &quot;sortNo&quot;: 0, &quot;level&quot;: 4 }, { &quot;id&quot;: &quot;1671445634122588247&quot;, &quot;createTime&quot;: &quot;2023-07-07 18:18:59&quot;, &quot;createDay&quot;: &quot;2023-07-07&quot;, &quot;updateTime&quot;: &quot;2023-07-28 17:19:19&quot;, &quot;createBy&quot;: &quot;1671403256519078006&quot;, &quot;updateBy&quot;: &quot;1671403256519078006&quot;, &quot;dataState&quot;: &quot;0&quot;, &quot;remark&quot;: &quot;&quot;, &quot;parentDeptNo&quot;: &quot;100001000000000&quot;, &quot;deptNo&quot;: &quot;100001029000000&quot;, &quot;deptName&quot;: &quot;大管家&quot;, &quot;sortNo&quot;: 0, &quot;leaderId&quot;: &quot;1671403256519078076&quot;, &quot;leaderName&quot;: &quot;你是是&quot;, &quot;level&quot;: 4 } ], &quot;operationTime&quot;: &quot;2023-08-27 11:25:01&quot;} 注意⚠️： 在 请求示例 中的”parentDeptNo”: “”, //父部门编号，就是根据点击折叠就是发送一次请求！ 在 响应示例 中，”createDay”: “2023-07-09” 没有显示时分秒，后期需要单独处理一下！ 思路： 调用mapper来得到dept部门的列表，此时返回的是dept类型的 因为返回的时候是要用deptVo，所以要转换一下 遍历这个vo列表，每个列表都设置日期格式化 返回 控制层 1234567891011121314151617181920@Slf4j@Api(tags = &quot;部门管理&quot;)@RestController@RequestMapping(&quot;dept&quot;)public class DeptController { @Autowired private DeptService deptService; @PostMapping(&quot;/list&quot;) @ApiImplicitParam(name = &quot;deptDto&quot;,value = &quot;部门DTO对象&quot;,required = true,dataType = &quot;DeptDto&quot;) @ApiOperationSupport( includeParameters = {&quot;deptDto.dataState&quot;,&quot;deptDto.deptName&quot;,&quot;deptDto.parentDeptNo&quot;} ) public ResponseResult list(@RequestBody DeptDto deptDto){//因为是post请求，所以要用对象的方式进行接受 List&lt;DeptVo&gt; deptVoList = deptService.getList(deptDto); return ResponseResult.success(deptVoList); } 服务接口 12345678910111213/** * 部门表服务类 */public interface DeptService { /** * 条件查询部门列表 * @param deptDto * @return */ List&lt;DeptVo&gt; getList(DeptDto deptDto);} 服务实现类 1234567891011121314151617181920/** * 部门表服务实现类 */@Servicepublic class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; /** * 条件查询部门列表 * * @param deptDto * @return */ @Override public List&lt;DeptVo&gt; getList(DeptDto deptDto) { return deptMapper.getList(deptDto); }} 1234@Mapperpublic interface DeptMapper { List&lt;DeptVo&gt; getList(DeptDto deptDto);} Sql 分析 12345678select sd.*, su.real_name from sys_dept sd left join sys_user su on sd.leader_id = su.id; Mapper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;mapper namespace=&quot;com.zzyl.mapper.DeptMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.zzyl.entity.Dept&quot;&gt; &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;parent_dept_no&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;parentDeptNo&quot;/&gt; &lt;result column=&quot;dept_no&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deptNo&quot;/&gt; &lt;result column=&quot;dept_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deptName&quot;/&gt; &lt;result column=&quot;sort_no&quot; jdbcType=&quot;INTEGER&quot; property=&quot;sortNo&quot;/&gt; &lt;result column=&quot;data_state&quot; jdbcType=&quot;CHAR&quot; property=&quot;dataState&quot;/&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot;/&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot;/&gt; &lt;result column=&quot;create_by&quot; jdbcType=&quot;BIGINT&quot; property=&quot;createBy&quot;/&gt; &lt;result column=&quot;update_by&quot; jdbcType=&quot;BIGINT&quot; property=&quot;updateBy&quot;/&gt; &lt;result column=&quot;leader_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;leaderId&quot;/&gt; &lt;result column=&quot;leader_name&quot; jdbcType=&quot;BIGINT&quot; property=&quot;leaderName&quot;/&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;BaseResultVoMap&quot; type=&quot;com.zzyl.vo.DeptVo&quot;&gt; &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;parent_dept_no&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;parentDeptNo&quot;/&gt; &lt;result column=&quot;dept_no&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deptNo&quot;/&gt; &lt;result column=&quot;dept_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;deptName&quot;/&gt; &lt;result column=&quot;sort_no&quot; jdbcType=&quot;INTEGER&quot; property=&quot;sortNo&quot;/&gt; &lt;result column=&quot;data_state&quot; jdbcType=&quot;CHAR&quot; property=&quot;dataState&quot;/&gt; &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot;/&gt; &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot;/&gt; &lt;result column=&quot;create_by&quot; jdbcType=&quot;BIGINT&quot; property=&quot;createBy&quot;/&gt; &lt;result column=&quot;update_by&quot; jdbcType=&quot;BIGINT&quot; property=&quot;updateBy&quot;/&gt; &lt;result column=&quot;leader_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;leaderId&quot;/&gt; &lt;result column=&quot;role_id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;roleId&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getList&quot; resultType=&quot;com.zzyl.vo.DeptVo&quot;&gt; select d.id, d.parent_dept_no, d.dept_no, d.dept_name, d.sort_no, d.data_state, d.create_time, d.update_time, d.create_by, d.update_by, d.remark, d.leader_id , u.real_name as leader_name,DATE_FORMAT(d.create_time,'%Y-%m-%d') as create_day from sys_dept d left join sys_user u on u.id = leader_id &lt;where&gt; &lt;if test=&quot;deptName!=null and deptName!=''&quot;&gt; and d.dept_name like concat('%',#{deptName},'%') &lt;/if&gt; &lt;if test=&quot;parentDeptNo!=null and parentDeptNo!=''&quot;&gt; and d.parent_dept_no like concat(#{parentDeptNo},'%') &lt;/if&gt; &lt;if test=&quot;dataState!=null and dataState!=''&quot;&gt; and d.data_state=#{dataState} &lt;/if&gt; &lt;/where&gt; order by d.sort_no asc, d.create_time desc &lt;/select&gt;&lt;/mapper&gt; 其中重点的就是 DATE_FORMAT(d.create_time,’%Y-%m-%d’) 因为前端页面上不需要展示和具体的是十分秒，所以要格式化一下。 u.id = leader_id 因为展示的时候有部门负责人所以要关联一下表。 部门树形结构接口🌟 难点在于如何把它组装成一颗树： 由于是初始化部门的树形结构，这个接口需要在部门中去定义 接口地址:/dept/tree 请求方式:POST 请求示例: 无 响应示例: 1234567891011121314151617181920212223242526272829303132{ &quot;code&quot;: 200, &quot;msg&quot;: &quot;操作成功&quot;, &quot;data&quot;: { &quot;items&quot;: [ { &quot;id&quot;: &quot;100001000000000&quot;, &quot;label&quot;: &quot;智慧养老院&quot;, &quot;children&quot;: [ { &quot;id&quot;: &quot;100001001000000&quot;, &quot;label&quot;: &quot;院长办公室&quot; }, { &quot;id&quot;: &quot;100001002000000&quot;, &quot;label&quot;: &quot;财务部&quot;, &quot;children&quot;: [ { &quot;id&quot;: &quot;100001002001000&quot;, &quot;label&quot;: &quot;会计组&quot; }, { &quot;id&quot;: &quot;100001002002000&quot;, &quot;label&quot;: &quot;结算组&quot; } ] } ] } ] }} 得用递归的方法 ： 分析 items 是一个集合，集合中又又对象，对象中又有另外一个集合。 所以说在设计返回值的时候。 12345678910public class TreeVo implements Serializable { @ApiModelProperty(value = &quot;tree数据&quot;) private List&lt;TreeItemVo&gt; items; @Builder public TreeVo(List&lt;TreeItemVo&gt; items) { this.items = items; }} 12345678910public class TreeItemVo implements Serializable { @ApiModelProperty(value = &quot;节点ID&quot;) public String id; @ApiModelProperty(value = &quot;显示内容&quot;) public String label; @ApiModelProperty(value = &quot;显示内容&quot;) public List&lt;TreeItemVo&gt; children = new ArrayList&lt;&gt;();//又包含自己 集合之中装的又是它本身。 思路： 先拿到最根部门的编号，我们设计了固定值。 构建一个DeptDto,赋值赋部门编号，状态为0，父部门编号处理一下设置进去，一会下面方法要用这个类型的参数 调用方法传进去dto拿到部门所有数据 检查当拿到的数据是否为空，否则报错 构建一个空所建数据结构的类型的，一会准备好准备装配返回 从所有部门数据的里面遍历拿到根下的第一个数据才是我们设置的“根”，也就是父部门是上面拿到的固定值的那个。 ⚠️递归调用组装数据，传入上面定义的要（存放递归生成的子节点，根的数据、总的数据） 构建根部门对象类型把里面的值设置进去 找子集，根据当前部门的编号作为父部门的编号，遍历每个数据，找到父部门是当前封装好的节点的部门集合 判断是否为空，如果不为空就是有子 构建一个装子部门的列表 把当前拿到的子部门进行遍历，继续找子部门，找不到为止，也就是依据当前的进行遍历 为了组装返回值item里面的数据返回 123456@PostMapping(&quot;/tree&quot;)public ResponseResult&lt;TreeVo&gt; deptTree(){ TreeVo treeVo = deptService.deptTree(); return ResponseResult.success(treeVo);} 12345/** * 查询部门树形结构 * @return */ TreeVo deptTree(); 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 查询部门树形结构 * * @return */ @Override public TreeVo deptTreeVo() { String rootDeptParentId = SuperConstant.ROOT_DEPT_PARENT_ID; DeptDto deptDto = DeptDto.builder().parentDeptNo(rootDeptParentId).build(); List&lt;DeptVo&gt; deptVoList = findDeptList(deptDto);//拿到了所有的部门 //创一个新的 List&lt;TreeItemVo&gt; items = new ArrayList&lt;&gt;();//待组装的 DeptVo rootDept = deptVoList.stream().filter(d -&gt; d.getParentDeptNo().equals(rootDeptParentId)).collect(Collectors.toList()).get(0); recursionTreeItem(items,rootDept,deptVoList); return TreeVo.builder().items(items).build(); } /** * 递归 * @param items * @param rootDept * @param deptVoList */ private void recursionTreeItem(List&lt;TreeItemVo&gt; items, DeptVo rootDept, List&lt;DeptVo&gt; deptVoList) { //根据定义的数据结构，构建出含有名称和ID的那个 TreeItemVo treeItemVo = TreeItemVo.builder().id(rootDept.getDeptNo()).label(rootDept.getDeptName()).build(); //根据当前部门的编号为父部门编号，找到他的子集 List&lt;DeptVo&gt; childrenList = deptVoList.stream().filter(d -&gt; d.getParentDeptNo().equals(rootDept.getDeptNo())).collect(Collectors.toList()); //判断是否为空 if (!EmptyUtil.isNullOrEmpty(childrenList)){ List&lt;TreeItemVo&gt; listChildrenList = new ArrayList&lt;&gt;(); //进行遍历每一个 childrenList.forEach( dept -&gt; { recursionTreeItem(listChildrenList,dept,deptVoList); }); } items.add(treeItemVo); } 部门添加接口地址:/dept 请求方式:PUT 接口描述:部门添加 请求示例: 12345678{ &quot;dataState&quot;: &quot;&quot;,//部门状态 &quot;deptName&quot;: &quot;&quot;,//部门名称 &quot;leaderId&quot;: 0, // 部门负责人id &quot;parentDeptNo&quot;: &quot;&quot;, //上级部门编号 &quot;remark&quot;: &quot;&quot;, //部门说明 &quot;sortNo&quot;: 0 //排序} 响应示例: 123456{ &quot;code&quot;: 0, &quot;data&quot;: true, &quot;msg&quot;: &quot;&quot;, &quot;operationTime&quot;: &quot;&quot;} 输入框里面的参数都能与请求示例相匹配。 思路： 由于dto数据不全，进行转换成标志的 根据父部门的编号生成一个子部门编号 部门不能超过4级，利用下面的算法判断一下，如果等于5就代表超过了4级，超过就报错 利用父部门编号生成一个部门的dto下面要根据dto来查询这个父部门下的子所有子部门 调用方法找到父部门下的子所有子部门 如果子部门为空就代表得创建一个子部门，就是调用方法，把父部门编号扔进去就会得到子 否则就根据有的子部门进行累加，遍历子部门把每一个子部门变返回比较最大的 调用createNo方法来输入进去生成 设置进去新的部门编号 调用mapper进行保存操作 如果flag == 1 则就是失败了 否则就是true 控制层 123456789101112131415@PutMapping @ApiOperation(value = &quot;部门添加&quot;,notes = &quot;部门添加&quot;) @ApiImplicitParam(name = &quot;deptDto&quot;,value = &quot;部门DTO对象&quot;,required = true,dataType = &quot;DeptDto&quot;) @ApiOperationSupport(includeParameters = { &quot;deptDto.dataState&quot;, &quot;deptDto.deptName&quot;, &quot;deptDto.leaderId&quot;, &quot;deptDto.remark&quot;, &quot;deptDto.sortNo&quot;, &quot;deptDto.parentDeptNo&quot;}) public ResponseResult&lt;DeptVo&gt; createDpt(@RequestBody DeptDto deptDto){ //创建成功 true 和 false Boolean flag = deptService.createDpt(deptDto); return ResponseResult.success(flag); } 服务层 123456/** * 添加部门 * @param deptDto * @return */ Boolean createDpt(DeptDto deptDto); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 添加部门 * * @param deptDto * @return */ @Override public Boolean createDpt(DeptDto deptDto) { //进行数据转换 Dept dept = BeanUtil.copyProperties(deptDto, Dept.class); //根据父部门编号生成当前部门编号 // 100001000000000 // 情况1 ： 当前父部门编号，没有子部门 100001001000000 // 情况2 ： 当前有子部门， 100001001000000 100001002000000 100001003000000 //传入父部门，得到子部门 String deptNo = createDptNo(deptDto.getParentDeptNo()); //重新设置进去 dept.setDeptNo(deptNo); //保存 int flag = deptMapper.insert(dept);//返回的是影响的行数 if (flag != 1){ throw new BaseException(&quot;保存部门不成功&quot;); } return true;}/** * 生成部门编号 * @param parentDeptNo * @return */ private String createDptNo(String parentDeptNo) { //100001001001001 ---&gt; 100001001001001 15位 代表 5 级 15/3 //100001001001000 ---&gt; 100001001001 12位 代表 4 级 //100001001000000 ---&gt; 100001001 9位 代表 3 级 if (NoProcessing.processString(parentDeptNo).length() / 3 == 5){ throw new BaseException(&quot;部门不能超过4级&quot;); } //查询一下有没有部门 DeptDto deptDto = DeptDto.builder().parentDeptNo(parentDeptNo).build(); List&lt;DeptVo&gt; deptVoList = deptMapper.getList(deptDto); if (EmptyUtil.isNullOrEmpty(deptVoList)){ //情况1 ： 当前父部门编号，没有子部门 100001001000000 return NoProcessing.createNo(parentDeptNo,false); } else { //情况2 ： 当前有子部门， 100001001000000 100001002000000 100001003000000 //先 想办法拿到最后一个 然后再 + 1 Long aLong = deptVoList.stream().map(d -&gt; { return Long.valueOf(d.getDeptNo()); }).max(Comparator.comparing(i -&gt; i)).get();//拿到了最大的部门编号 return NoProcessing.createNo(String.valueOf(aLong),true); } } mapper 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;insert id=&quot;insert&quot; parameterType=&quot;com.zzyl.entity.Dept&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into sys_dept &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;parentDeptNo != null&quot;&gt; parent_dept_no, &lt;/if&gt; &lt;if test=&quot;deptNo != null&quot;&gt; dept_no, &lt;/if&gt; &lt;if test=&quot;deptName != null&quot;&gt; dept_name, &lt;/if&gt; &lt;if test=&quot;sortNo != null&quot;&gt; sort_no, &lt;/if&gt; &lt;if test=&quot;dataState != null&quot;&gt; data_state, &lt;/if&gt; &lt;if test=&quot;createTime != null&quot;&gt; create_time, &lt;/if&gt; &lt;if test=&quot;updateTime != null&quot;&gt; update_time, &lt;/if&gt; &lt;if test=&quot;createBy != null&quot;&gt; create_by, &lt;/if&gt; &lt;if test=&quot;updateBy != null&quot;&gt; update_by, &lt;/if&gt; &lt;if test=&quot;leaderId != null&quot;&gt; leader_id, &lt;/if&gt; &lt;if test=&quot;remark != null&quot;&gt; remark, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;parentDeptNo != null&quot;&gt; #{parentDeptNo,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test=&quot;deptNo != null&quot;&gt; #{deptNo,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test=&quot;deptName != null&quot;&gt; #{deptName,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test=&quot;sortNo != null&quot;&gt; #{sortNo,jdbcType=INTEGER}, &lt;/if&gt; &lt;if test=&quot;dataState != null&quot;&gt; #{dataState,jdbcType=CHAR}, &lt;/if&gt; &lt;if test=&quot;createTime != null&quot;&gt; #{createTime,jdbcType=TIMESTAMP}, &lt;/if&gt; &lt;if test=&quot;updateTime != null&quot;&gt; #{updateTime,jdbcType=TIMESTAMP}, &lt;/if&gt; &lt;if test=&quot;createBy != null&quot;&gt; #{createBy,jdbcType=BIGINT}, &lt;/if&gt; &lt;if test=&quot;updateBy != null&quot;&gt; #{updateBy,jdbcType=BIGINT}, &lt;/if&gt; &lt;if test=&quot;leaderId != null&quot;&gt; #{leaderId,jdbcType=BIGINT}, &lt;/if&gt; &lt;if test=&quot;remark != null&quot;&gt; #{remark,jdbcType=VARCHAR} &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; 部门修改接口地址:/dept 请求方式:PATCH 请求示例: 123456789{ &quot;dataState&quot;: &quot;&quot;,//部门状态 &quot;deptName&quot;: &quot;&quot;,//部门名称 &quot;leaderId&quot;: 0, // 部门负责人id &quot;parentDeptNo&quot;: &quot;&quot;, //上级部门编号 &quot;remark&quot;: &quot;&quot;, //部门说明 &quot;sortNo&quot;: 0, //排序 &quot;id&quot;:1671445634122588232 // 主键} 响应示例: 123456{ &quot;code&quot;: 0, &quot;data&quot;: true, &quot;msg&quot;: &quot;&quot;, &quot;operationTime&quot;: &quot;&quot;} 💡思路: 先转换成标准的类型 检验是否可以修改，检查是否为1 是禁用 检查该部门下是否存在子部门 检查该部门是否存在用户 调用方法进行修改 验证修改结果是否为0，表示修改失败 代码实现 1234567891011121314151617181920public Boolean updateDept(DeptDto deptDto) { Dept dept = BeanUtil.toBean(deptDto, Dept.class); if (dept.getDataState().equals(&quot;1&quot;)){ //检查该部门下是否存在子部门 if (hasChildByDeptId(dept.getDeptNo())){ throw new RuntimeException(&quot;存在下级部门,不允许禁用&quot;); } if (checkDeptExistUser(dept.getDeptNo())){ throw new RuntimeException(&quot;部门存在用户,不允许禁用&quot;); } } int flag = deptMapper.insert(dept); if (flag == 0){ throw new RuntimeException(&quot;修改部门失败！&quot;); } return true; } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;insert id=&quot;insert&quot; parameterType=&quot;com.zzyl.entity.Dept&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Long&quot;&gt; # 将查询到的主建赋值给id SELECT LAST_INSERT_ID() # keyProperty是将id值自增 &lt;/selectKey&gt; insert into sys_dept &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;parentDeptNo != null&quot;&gt; parent_dept_no, &lt;/if&gt; &lt;if test=&quot;deptNo != null&quot;&gt; dept_no, &lt;/if&gt; &lt;if test=&quot;deptName != null&quot;&gt; dept_name, &lt;/if&gt; &lt;if test=&quot;sortNo != null&quot;&gt; sort_no, &lt;/if&gt; &lt;if test=&quot;dataState != null&quot;&gt; data_state, &lt;/if&gt; &lt;if test=&quot;createTime != null&quot;&gt; create_time, &lt;/if&gt; &lt;if test=&quot;updateTime != null&quot;&gt; update_time, &lt;/if&gt; &lt;if test=&quot;createBy != null&quot;&gt; create_by, &lt;/if&gt; &lt;if test=&quot;updateBy != null&quot;&gt; update_by, &lt;/if&gt; &lt;if test=&quot;leaderId != null&quot;&gt; leader_id, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;parentDeptNo != null&quot;&gt; #{parentDeptNo,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test=&quot;deptNo != null&quot;&gt; #{deptNo,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test=&quot;deptName != null&quot;&gt; #{deptName,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test=&quot;sortNo != null&quot;&gt; #{sortNo,jdbcType=INTEGER}, &lt;/if&gt; &lt;if test=&quot;dataState != null&quot;&gt; #{dataState,jdbcType=CHAR}, &lt;/if&gt; &lt;if test=&quot;createTime != null&quot;&gt; #{createTime,jdbcType=TIMESTAMP}, &lt;/if&gt; &lt;if test=&quot;updateTime != null&quot;&gt; #{updateTime,jdbcType=TIMESTAMP}, &lt;/if&gt; &lt;if test=&quot;createBy != null&quot;&gt; #{createBy,jdbcType=BIGINT}, &lt;/if&gt; &lt;if test=&quot;updateBy != null&quot;&gt; #{updateBy,jdbcType=BIGINT}, &lt;/if&gt; &lt;if test=&quot;leaderId != null&quot;&gt; #{leaderId,jdbcType=BIGINT}, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; 查看是否存在子部门123456789101112131415select count(*) from sys_dept where parent_dept_no = '100001009000000'; &lt;select id=&quot;hasChildByDeptId&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;int&quot;&gt; select count(1) from sys_dept where `parent_dept_no` = #{deptId} limit 1 &lt;/select&gt; count(1) 比 count(*) 性能更好，配合 limit 1，但凡查到存在一个子部门马上就停止！ 查看当前部门下否存在用户123456select * from sys_user where dept_no = '100001005000000'; 启用/禁用接口地址:/dept/is_enable 请求方式:PATCH 请求示例: 1234{ &quot;dataState&quot;: &quot;&quot;, //状态 &quot;id&quot;: 1671445634122588232} 响应示例: 123456{ &quot;code&quot;: 0, &quot;data&quot;: true, &quot;msg&quot;: &quot;&quot;, &quot;operationTime&quot;: &quot;&quot;} 思路💡： 根据部门编号查询数据库中是否存在部门 如果该部门为null，报错表示部门不存在 把对象设置进去新的状态 调用mapper进行修改 如果修改结果==0代表修改失败 实现 123456789101112131415161718192021222324252627/** * 启用-禁用部门 * * @param deptDto * @return */ @Caching(evict = {@CacheEvict(value = DeptCacheConstant.LIST,allEntries = true), @CacheEvict(value = DeptCacheConstant.TREE,allEntries = true)}) @Override public Boolean isEnable(DeptDto deptDto) { //根据部门编号查询数据库中是否存在部门 Dept dept = deptMapper.selectByDeptNo(deptDto.getDeptNo()); //如果为null，报错代表部门不存在 if (dept == null){ throw new BaseException(&quot;这个部门可是不存在啊！&quot;); } dept.setDataState(deptDto.getDataState()); //调用mapper进行修改 int flag = deptMapper.updateByPrimaryKey(dept); if (flag == 0){ throw new RuntimeException(&quot;修改失败了～～～～&quot;); } return true; } 岗位管理按照部门查询所有的岗位列表接口地址:/post/page/{pageNum}/{pageSize} 请求方式:POST 请求示例: 12345{ &quot;deptNo&quot;: &quot;&quot;,//部门编号 &quot;dataState&quot;: &quot;&quot;,//岗位状态 &quot;postName&quot;: &quot;&quot;//岗位名称} 响应示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364{ &quot;code&quot;: 200, &quot;msg&quot;: &quot;操作成功&quot;, &quot;data&quot;: { &quot;total&quot;: &quot;2&quot;, &quot;pageSize&quot;: 10, &quot;pages&quot;: &quot;1&quot;, &quot;page&quot;: 1, &quot;records&quot;: [ { &quot;id&quot;: &quot;1671446178337726569&quot;, &quot;createTime&quot;: &quot;2023-07-11 10:30:25&quot;, &quot;createDay&quot;: &quot;2023-07-11&quot;, &quot;createBy&quot;: &quot;1671403256519078006&quot;, &quot;dataState&quot;: &quot;0&quot;, &quot;remark&quot;: &quot;&quot;, &quot;deptNo&quot;: &quot;100001005000000&quot;, &quot;postNo&quot;: &quot;100001005002000&quot;, &quot;postName&quot;: &quot;财务主管&quot;, &quot;deptVo&quot;: { &quot;id&quot;: &quot;1671445634122588164&quot;, &quot;createTime&quot;: &quot;2023-06-22 11:42:36&quot;, &quot;updateTime&quot;: &quot;2023-06-30 09:14:16&quot;, &quot;createBy&quot;: &quot;1671362878457892866&quot;, &quot;updateBy&quot;: &quot;1&quot;, &quot;dataState&quot;: &quot;0&quot;, &quot;remark&quot;: &quot;啊实打实打阿萨德阿萨德按时&quot;, &quot;parentDeptNo&quot;: &quot;100001000000000&quot;, &quot;deptNo&quot;: &quot;100001005000000&quot;, &quot;deptName&quot;: &quot;财务部&quot;, &quot;sortNo&quot;: 2, &quot;leaderId&quot;: &quot;1671403256519077890&quot;, &quot;level&quot;: 4 } }, { &quot;id&quot;: &quot;1671446178337726568&quot;, &quot;createTime&quot;: &quot;2023-07-11 10:30:14&quot;, &quot;createDay&quot;: &quot;2023-07-11&quot;, &quot;createBy&quot;: &quot;1671403256519078006&quot;, &quot;dataState&quot;: &quot;0&quot;, &quot;deptNo&quot;: &quot;100001005000000&quot;, &quot;postNo&quot;: &quot;100001005001000&quot;, &quot;postName&quot;: &quot;结算员&quot;, &quot;deptVo&quot;: { &quot;id&quot;: &quot;1671445634122588164&quot;, &quot;createTime&quot;: &quot;2023-06-22 11:42:36&quot;, &quot;updateTime&quot;: &quot;2023-06-30 09:14:16&quot;, &quot;createBy&quot;: &quot;1671362878457892866&quot;, &quot;updateBy&quot;: &quot;1&quot;, &quot;dataState&quot;: &quot;0&quot;, &quot;remark&quot;: &quot;啊实打实打阿萨德阿萨德按时&quot;, &quot;parentDeptNo&quot;: &quot;100001000000000&quot;, &quot;deptNo&quot;: &quot;100001005000000&quot;, &quot;deptName&quot;: &quot;财务部&quot;, &quot;sortNo&quot;: 2, &quot;leaderId&quot;: &quot;1671403256519077890&quot;, &quot;level&quot;: 4 } } ] }, &quot;operationTime&quot;: &quot;2023-08-27 02:53:24&quot;} 思路: 分页helper传入分页数和分页大小 检查当前传进来的岗位dto不能为空 调用岗位查询的条件查询的mapper查询到当前部门下的所有岗位人 调用现成的方法把上面得到的所有岗位人放进去得到了响应参数里面格式的数据 如果当前响应格式里面的Records为不为空的话 遍历每一个里面的Records里并且把里面的每一个部门号封装成一个部门号列表 把当前整个响应里面的每一个Records遍历一下，往每个里面格式化一下创建时间 再次遍历所有的Records拿到每一个部门，拿到当前时间往里面格式化时间 遍历拿到的部门列表中的每一个部门和岗位中保存的部门id 进行对比。 代码实现12345678910111213141516171819/*** * 多条件查询岗位分页列表 * @param postDto 岗位Vo查询条件 * @param pageNum 页码 * @param pageSize 每页条数 * @return: PageResponse&lt;PostVo&gt; */ @PostMapping(&quot;page/{pageNum}/{pageSize}&quot;) @ApiOperation(value = &quot;岗位分页&quot;,notes = &quot;岗位分页&quot;) @ApiImplicitParams({ @ApiImplicitParam(name = &quot;postDto&quot;,value = &quot;岗位DTO对象&quot;,required = true,dataType = &quot;PostDto&quot;), @ApiImplicitParam(paramType = &quot;path&quot;,name = &quot;pageNum&quot;,value = &quot;页码&quot;,example = &quot;1&quot;,dataType = &quot;Integer&quot;), @ApiImplicitParam(paramType = &quot;path&quot;,name = &quot;pageSize&quot;,value = &quot;每页条数&quot;,example = &quot;10&quot;,dataType = &quot;Integer&quot;) }) public ResponseResult&lt;PageResponse&lt;PostVo&gt;&gt; findPostVoResponse(@RequestBody PostDto postDto,@PathVariable(&quot;pageNum&quot;) int pageNum,@PathVariable(&quot;pageSize&quot;) int pageSize){ PageResponse&lt;PostVo&gt; pageResponse = postService.findPostPage(postDto,pageNum,pageSize); return ResponseResult.success(pageResponse); } 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 多条件查询岗位表分页列表 * @param postDto 查询条件 * @param pageNum 页码 * @param pageSize 每页条数 * @return Page&lt;PostVo&gt; */ @Override public PageResponse&lt;PostVo&gt; findPostPage(PostDto postDto, int pageNum, int pageSize) { PageHelper.startPage(pageNum, pageSize); //检查一下传进来的dto是否为空 if (EmptyUtil.isNullOrEmpty(postDto)){ throw new BaseException(&quot;部门不能为空&quot;); } //先进行岗位查询,拿到了所有的岗位人 Page&lt;List&lt;Post&gt;&gt; page = postMapper.selectPage(postDto); //这里拿到了所有的响应数据 PageResponse&lt;PostVo&gt; pageResponse = PageResponse.of(page, PostVo.class); //检查当前响应数据如果不为空的话 if (!EmptyUtil.isNullOrEmpty(pageResponse.getRecords())){ List&lt;String&gt; deptNos = pageResponse.getRecords().stream().map(postVo -&gt; postVo.getDeptNo()).collect(Collectors.toList()); //根据拿到的部门号去拿到所有的部门 List&lt;Dept&gt; deptVoList = deptMapper.findDeptInDeptNos(deptNos); //遍历里面的每一个 pageResponse.getRecords().forEach(n -&gt;{ n.setCreateDay(LocalDateTimeUtil.format(n.getCreateTime(), &quot;yyyy-MM-dd&quot;)); deptVoList.forEach( d -&gt; { //对比岗位里面的保存的那个部门，外面的那个是不是一样 if (n.getDeptNo().equals(d.getDeptNo())){ n.setDeptVo(BeanConv.toBean(d,DeptVo.class)); } }); }); } return pageResponse; } 修改岗位其中的”编辑”、”启用”、”禁用” 三个按钮共用这个接口 接口地址:/post 请求方式:PATCH 请求示例: 1234567{ &quot;id&quot;: 0, //主键 &quot;deptNo&quot;: &quot;&quot;, //部门编号 &quot;remark&quot;: &quot;&quot;, //备注 &quot;dataState&quot;: &quot;&quot;,//是否启用(0:启用,1:禁用) &quot;postName&quot;: &quot;&quot; //岗位名称} 响应示例: 123456{ &quot;code&quot;: 0, &quot;data&quot;: true, &quot;msg&quot;: &quot;&quot;, &quot;operationTime&quot;: &quot;&quot;} 先转成标准的对象 判断 如果状态是禁用 申请一个空的字符串，一会用来存放岗位编码 根据传进来的拿到对应的岗位码,存放到字符串中 检查对应岗位下的员工数目 判断如果该岗位下有员工则报错 最后调用更新的mapper来更新 如果修改的数目为0 报错 代码实现12345678910111213141516/** * 修改岗位 * @param postDto 岗位DTO对象 * @return Boolean 是否修改成功 */ @PatchMapping @ApiOperation(value = &quot;岗位修改&quot;,notes = &quot;岗位修改&quot;) @ApiImplicitParam(name = &quot;postDto&quot;,value = &quot;岗位DTO对象&quot;,required = true,dataType = &quot;PostDto&quot;) @ApiOperationSupport(includeParameters = {&quot;postDto.deptNo&quot;,&quot;postDto.dataState&quot;,&quot;postDto.postName&quot;, &quot;postDto.remark&quot;, &quot;postDto.id&quot;}) public ResponseResult&lt;Boolean&gt; updatePost(@RequestBody PostDto postDto){ Boolean flag = postService.updatePost(postDto); return ResponseResult.success(flag); } 1234567891011121314151617181920212223242526272829/** * 修改岗位表 * @param postDto 对象信息 * @return Boolean */ @Override public Boolean updatePost(PostDto postDto){ Post post = BeanUtil.toBean(postDto, Post.class); //判断一下状态是否为禁用 if (post.getDataState().equals(&quot;1&quot;)){ //进来说明状态是禁用的 //申请一个空的字符串 String[] s= {&quot;&quot;}; //拿到对应的岗位 s[0] = post.getPostNo(); //查看当前岗位下有没有员工 Integer total = checkPostHasUser(s); if (total &gt; 0){ //说明有员工 throw new RuntimeException(&quot;岗位已分配,不能禁用&quot;); } } int flag = postMapper.updateByPrimaryKey(post); if (flag == 0){//说明失败了 throw new RuntimeException(&quot;修改职位信息出错&quot;); } return true; } 保存岗位接口地址:/post 请求方式:PUT 请求示例: 123456{ &quot;deptNo&quot;: &quot;&quot;, //部门编号 &quot;remark&quot;: &quot;&quot;, //备注 &quot;dataState&quot;: &quot;&quot;,//是否启用(0:启用,1:禁用) &quot;postName&quot;: &quot;&quot; //岗位名称} 响应示例: 123456{ &quot;code&quot;: 0, &quot;data&quot;: true, &quot;msg&quot;: &quot;&quot;, &quot;operationTime&quot;: &quot;&quot;} 转成正常的对象 根据传进来的，调用方法创建一个新的岗位编号 往传进来的里面设置进去岗位号 调用mapper来进行数据库插入操作 判断插入结果的返回数值，如果为0代表失败 转成前端友好的VO状态，作为一会返回的最终值 装备部门，装配数据的状态为0 位启用状态，从传进来的参数中拿到部门编号作为父部门编号 根据传部门找该部门下的所有部门列表 如果部门列表不为空则那部门列表中第一个元素作为部门，此处需要专为前端专用的vo，把它设置到前面封装的返回结果级中，如果为空就直接下一步返回了啥，说明地下没有节点了 代码实现123456789101112131415161718192021222324@Override public PostVo createPost(PostDto postDto) { Post post = BeanUtil.toBean(postDto, Post.class); String postNo = createPostNo(post.getDeptNo()); //把岗位设置上去 post.setPostNo(postNo); int flag = postMapper.insert(post); if (flag == 0){ new RuntimeException(&quot;保存职位信息出错&quot;); } PostVo postVoResult = BeanConv.toBean(post, PostVo.class); //装备部门,这是为了下一步的查询做准备 DeptDto deptDto = DeptDto.builder().dataState(SuperConstant.DATA_STATE_0) .parentDeptNo(postDto.getDeptNo()).build(); List&lt;Dept&gt; deptList = deptMapper.selectList(deptDto);//拿到部门的list if (!EmptyUtil.isNullOrEmpty(deptList)){ postVoResult.setDeptVo(BeanConv.toBean(deptList.get(0),DeptVo.class)); } return postVoResult; }","link":"/2025/02/18/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[],"pages":[]}