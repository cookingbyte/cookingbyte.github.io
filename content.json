{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/1985/10/26/hello-world/"},{"title":"基础项目开发","text":"养老项目一、基础数据开发前瞻知识点 为什么要区分 DTO 和 VO 对象？ 因为有些情况不想传完整的数据进去，vo相当于能过滤一遍，只发送必要的数据。 护理接口分页查询数据创建一个dto对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 护理项目数据传输对象 */@Datapublic class NursingProjectDto extends BaseDto { /** * 名称 */ @ApiModelProperty(value = &quot;名称&quot;) private String name; /** * 排序号 */ @ApiModelProperty(value = &quot;排序号&quot;) private Integer orderNo; /** * 单位 */ @ApiModelProperty(value = &quot;单位&quot;) private String unit; /** * 价格 */ @ApiModelProperty(value = &quot;价格&quot;) private BigDecimal price; /** * 图片 */ @ApiModelProperty(value = &quot;图片&quot;) private String image; /** * 护理要求 */ @ApiModelProperty(value = &quot;护理要求&quot;) private String nursingRequirement; /** * 状态（0：禁用，1：启用） */ @ApiModelProperty(value = &quot;状态（0：禁用，1：启用）&quot;) private Integer status;} Controll12345678910111213141516171819202122232425/** * @author geb * @create 2025-01-27-10:59 AM */@RestController@RequestMapping(&quot;/nursing_project&quot;)public class NursingProjectController extends BaseController{ @Autowired private NursingProjectService nursingProjectService; @GetMapping public ResponseResult getByPage(@RequestParam(value = &quot;name&quot;, required = false) String name, @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;10&quot;) Integer pageSize, @RequestParam(value = &quot;status&quot;,required = false) Integer status) { PageResponse&lt;NursingProjectVo&gt; page = nursingProjectService.getPage(name, pageNum, pageSize, status); return success(page); }} Service123456789/** * @author geb * @create 2025-02-05-1:34 PM */public interface NursingProjectService { public PageResponse&lt;NursingProjectVo&gt; getPage(String name,Integer pageNum,Integer pageSize,Integer state);} ServiceImpl1234567891011121314151617181920212223/** * @author geb * @create 2025-02-05-1:40 PM */@Servicepublic class NursingProjectServiceImpl implements NursingProjectService { @Autowired private NursingProjectMapper nursingProjectMapper; @Override public PageResponse&lt;NursingProjectVo&gt; getPage(String name, Integer pageNum, Integer pageSize, Integer status) { //分页 PageHelper.startPage(pageNum,pageSize); Page&lt;NursingProjectVo&gt; projectVoPage = nursingProjectMapper.getByPage(name, pageNum, pageSize, status); return PageResponse.of(projectVoPage,NursingProjectVo.class); }} Mapper123456789@Mapperpublic interface NursingProjectMapper { public Page&lt;NursingProjectVo&gt; getByPage( String name, Integer pageNum, Integer pageSize, Integer status );} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.zzyl.mapper.NursingProjectMapper&quot;&gt; &lt;resultMap id=&quot;nursingProjectResultMap&quot; type=&quot;com.zzyl.vo.NursingProjectVo&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;order_no&quot; property=&quot;orderNo&quot;/&gt; &lt;result column=&quot;unit&quot; property=&quot;unit&quot;/&gt; &lt;result column=&quot;price&quot; property=&quot;price&quot;/&gt; &lt;result column=&quot;image&quot; property=&quot;image&quot;/&gt; &lt;result column=&quot;nursing_requirement&quot; property=&quot;nursingRequirement&quot;/&gt; &lt;result column=&quot;status&quot; property=&quot;status&quot;/&gt; &lt;result column=&quot;create_by&quot; property=&quot;createBy&quot;/&gt; &lt;result column=&quot;update_by&quot; property=&quot;updateBy&quot;/&gt; &lt;result column=&quot;remark&quot; property=&quot;remark&quot;/&gt; &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot;/&gt; &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot;/&gt; &lt;result column=&quot;creator&quot; property=&quot;creator&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getByPage&quot; resultMap=&quot;nursingProjectResultMap&quot;&gt; select np.id, np.name, np.order_no, np.unit, np.price, np.image, np.nursing_requirement, np.status, np.create_by, np.update_by, np.remark, np.create_time, np.update_time, su.real_name from nursing_project np left join sys_user su on np.create_by=su.id &lt;where&gt; &lt;if test=&quot;name != null and name != ''&quot;&gt; and name like concat('%',#{name},'%') &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; and status = #{status} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; ![image-20250206114812693](/Users/gebin/Library/Application Support/typora-user-images/image-20250206114812693.png) 新增Controll123456789101112/** * 添加护理项目 * @param nursingProjectDto * @return */ @PostMapping public ResponseResult add(@RequestBody NursingProjectDto nursingProjectDto){ nursingProjectService.add(nursingProjectDto); return success();} Service12345/** * 添加护理项目 * @param nursingProjectDto */ void add(NursingProjectDto nursingProjectDto); ServiceImpl12345678910111213/** * 添加护理项目 * * @param nursingProjectDto */ @Override public void add(NursingProjectDto nursingProjectDto) { //对象的转换 把当前nursingProjectDto 里面的所有属性都拷贝到NursingProject 中，因为nursingProjectDto 中的属性不全 NursingProject nursingProject = BeanUtil.copyProperties(nursingProjectDto, NursingProject.class); //调用mapper nursingProjectMapper.insert(nursingProject); } Mapper1void insert(NursingProject nursingProject); 123456&lt;insert id=&quot;insert&quot;&gt; insert into nursing_project (name, order_no, unit, price, image, nursing_requirement, status, create_by, update_by, remark, create_time, update_time) values (#{name}, #{orderNo}, #{unit}, #{price}, #{image}, #{nursingRequirement}, #{status}, #{createBy}, #{updateBy}, #{remark}, #{createTime}, #{updateTime})&lt;/insert&gt; ![image-20250206170214310](/Users/gebin/Library/Application Support/typora-user-images/image-20250206170214310.png) 编辑回显数据– 根据ID查询数据Controll1234567@GetMapping(&quot;/{id}&quot;) public ResponseResult getById(@PathVariable(&quot;id&quot;) Long id){ NursingProjectVo nursingProjectVo = nursingProjectService.getById(id); return success(nursingProjectVo);} Service123456 /** * 根据id 查询护理项目 * @param id * @return */NursingProjectVo getById(Long id); ServiceImpl12345678910/** * 根据id 查询护理项目 * * @param id * @return */ @Overridepublic NursingProjectVo getById(Long id) { return nursingProjectMapper.getById(id);} Mapper1NursingProjectVo getById(Long id); 12345&lt;select id=&quot;getById&quot; resultMap=&quot;nursingProjectResultMap&quot;&gt; select * from nursing_project where id = #{id}&lt;/select&gt; ![image-20250206175745552](/Users/gebin/Library/Application Support/typora-user-images/image-20250206175745552.png) 此时，回显数据成功 更新数据Controll12345@PutMapping public ResponseResult update(@RequestBody NursingProjectDto nursingProjectDto){ nursingProjectService.update(nursingProjectDto); return success(); } Service12345/** * 修改护理项目 * @param nursingProjectDto */ void update(NursingProjectDto nursingProjectDto); ServiceImpl1234567891011/** * 修改护理项目 * * @param nursingProjectDto */ @Override public void update(NursingProjectDto nursingProjectDto) { NursingProject nursingProject = new NursingProject(); BeanUtils.copyProperties(nursingProjectDto, nursingProject); nursingProjectMapper.update(nursingProject); } Mapper1void update(NursingProject nursingProject); 1234567891011121314&lt;update id=&quot;update&quot;&gt; update nursing_project set name = #{name}, order_no = #{orderNo}, unit = #{unit}, price = #{price}, image = #{image}, nursing_requirement = #{nursingRequirement}, status = #{status}, update_by = #{updateBy}, remark = #{remark}, update_time = #{updateTime} where id = #{id} &lt;/update&gt; 二、微信登录Controll12345678910111213141516@RestController@RequestMapping(&quot;/customer/user&quot;)@Api(tags = &quot;小程序登录&quot;)public class CustomerUserController extends BaseController { @Autowired private MemberService memberService; @PostMapping(&quot;/login&quot;) @ApiOperation(&quot;登录&quot;) public ResponseResult&lt;LoginVo&gt; login(@RequestBody UserLoginRequestDto dto){ LoginVo loginVo = memberService.login(dto); return ResponseResult.success(loginVo); }} Service123456789101112/** * 用户管理 */public interface MemberService { /** * 登录方法 * @param dto * @return */ LoginVo login(UserLoginRequestDto dto);} ServiceImpl获取手机号1234567891011121314151617181920212223242526272829303132333435363738394041/** * 用户管理 */@Slf4j@Servicepublic class MemberServiceImpl implements MemberService { @Autowired private WechatService wechatService; @Autowired private MemberMapper memberMapper; @Autowired private JwtTokenManagerProperties jwtTokenManagerProperties; static ArrayList DEFAULT_NICKNAME_PREFIX = Lists.newArrayList( &quot;生活更美好&quot;, &quot;大桔大利&quot;, &quot;日富一日&quot;, &quot;好柿开花&quot;, &quot;柿柿如意&quot;, &quot;一椰暴富&quot;, &quot;大柚所为&quot;, &quot;杨梅吐气&quot;, &quot;天生荔枝&quot; ); /** * 登录方法 * * @param dto * @return */ @Override public LoginVo login(UserLoginRequestDto dto) { //1. 根据code 调用api 获取 openid ，由于很多情况要调用api，所以 封装 出去！！！ String openId = wechatService.getOpenId(dto.getCode()); 此时，因为其他功能会调用 根据code 调用api 获取 openid 这个功能，所以封装出去。 12345678910111213141516171819public interface WechatService { /** * 获取openID * @param code 前端传过来的凭证 * @return */ public String getOpenId(String code); /** * 获取手机号 * @param phoneCode * @return */ public String getPhone(String phoneCode); } 12345678910111213141516171819202122232425262728293031@Service@Slf4jpublic class WechatServiceImpl implements WechatService { // 登录 private static final String REQUEST_URL = &quot;https://api.weixin.qq.com/sns/jscode2session?grant_type=authorization_code&quot;; // 获取token private static final String TOKEN_URL = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&quot;; // 获取手机号 private static final String PHONE_REQUEST_URL = &quot;https://api.weixin.qq.com/wxa/business/getuserphonenumber?access_token=&quot;; @Value(&quot;${zzyl.wechat.appId}&quot;) private String appId; @Value(&quot;${zzyl.wechat.appSecret}&quot;) private String secret; /** * 获取openID * * @param code * @return */ @Override public String getOpenId(String code) { //使用糊涂工具 Map&lt;String,Object&gt; requestParamMap = getAppConfig();//封装结束,这个封装了前两项 requestParamMap.put(&quot;js_code&quot;, code);//继续封装进去code 封装依照下面图片内容来自官方文档 ![image-20250212144535240](/Users/gebin/Library/Application Support/typora-user-images/image-20250212144535240.png) 123456789101112/** * 封装参数 * @return */ private Map&lt;String, Object&gt; getAppConfig() { Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); resultMap.put(&quot;appid&quot;,appId);//配置文件中有 resultMap.put(&quot;secret&quot;,secret); return resultMap; } 又因为官方返回实例是 ![image-20250212144911268](/Users/gebin/Library/Application Support/typora-user-images/image-20250212144911268.png) https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html 12345678910111213141516171819String result = HttpUtil.get(REQUEST_URL, requestParamMap);//这就是官方要求的格式 /* { result 的样子如下 -----------我要拿到里面的openid &quot;openid&quot;:&quot;xxxxxx&quot;, &quot;session_key&quot;:&quot;xxxxx&quot;, &quot;unionid&quot;:&quot;xxxxx&quot;, &quot;errcode&quot;:0, &quot;errmsg&quot;:&quot;xxxxx&quot; }*/ //字符串转成 json JSONObject jsonObject = JSONUtil.parseObj(result);//JSONObject 本质就是一个增强的map，所以当成map用 //判断接口是否请求成功 if (ObjectUtil.isNotEmpty(jsonObject.getInt(&quot;errcode&quot;))){ throw new BaseException(jsonObject.getStr(&quot;errmsg&quot;)); } return jsonObject.getStr(&quot;openid&quot;); } 属于 上面的 getOpenId 这个方法 获取openId需要的参数 ![image-20250212155044000](/Users/gebin/Library/Application Support/typora-user-images/image-20250212155044000.png) 它需要调用的是下面这张图的接口 ![image-20250212155616890](/Users/gebin/Library/Application Support/typora-user-images/image-20250212155616890.png) 12345678910111213141516171819/** * 获取手机号 * https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-info/phone-number/getPhoneNumber.html * @param phoneCode * @return */ @Override public String getPhone(String phoneCode) { //此处要封装一个token方法 String token = getToken();//拿到了token String url = PHONE_REQUEST_URL + token;//作为一个url //最后把code封装进去 Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(&quot;code&quot;,phoneCode);//如下图，除了拼接一个还需要code参数 //根据开发文档进行调用 String result = HttpUtil.post(url, JSONUtil.toJsonStr(param)); ![image-20250212160748296](/Users/gebin/Library/Application Support/typora-user-images/image-20250212160748296.png) 因为非body参数，所以要拼接，String url = PHONE_REQUEST_URL + token;//作为一个url进行传递 123456789101112131415161718192021222324252627282930 //字符串转成 json JSONObject jsonObject = JSONUtil.parseObj(result);//JSONObject 本质就是一个增强的map，所以当成map用 //判断接口是否请求成功 if (jsonObject.getInt(&quot;errcode&quot;) != 0){ //不等于0 代表成功 throw new BaseException(jsonObject.getStr(&quot;errmsg&quot;)); } return jsonObject.getJSONObject(&quot;phone_info&quot;).getStr(&quot;phoneNumber&quot;); } public String getToken(){ Map&lt;String, Object&gt; map = getAppConfig();//之前封装的 String result = HttpUtil.get(TOKEN_URL, map);//使用 HttpUtil.get 方法发送 HTTP GET 请求到微信服务器。 //字符串转成 json JSONObject jsonObject = JSONUtil.parseObj(result);//JSONObject 本质就是一个增强的map，所以当成map用,方便一会拿里面需要的东西 //判断接口是否请求成功 if (ObjectUtil.isNotEmpty(jsonObject.getInt(&quot;errcode&quot;))){ throw new BaseException(jsonObject.getStr(&quot;errmsg&quot;)); }// 返回实例// {// &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,// &quot;expires_in&quot;:7200// } return jsonObject.getStr(&quot;access_token&quot;);//拿到里面的access_token的值 } 微信登录总结 解释： 首先，前端调用了login 方法，会给我们返回三个参数。我们端接受到三个参数之后，首先使用了登录接口来拿到openid这个微信的专属认证标志，代码中我们用getOpenId封装来实现的。 拿到openid之后来查询客户的信息，判断是否为空，如果为空就说明第一次登录，我们需要创建一个新的用户然后赋值新的openid； 然后是获取手机号的方法，在代码中我们是通过 wechatService.getPhone(dto.getPhoneCode()) 封装到wechatService实现，拿到手机号。 拦截器前置知识 ![image-20250213115137206](/Users/gebin/Library/Application Support/typora-user-images/image-20250213115137206.png) ==每个请求==都是一个单独的线程，李四过来也是单独开始一个线程，都会开辟一块新空间！ ![image-20250213115809329](/Users/gebin/Library/Application Support/typora-user-images/image-20250213115809329.png) 代码实现必须实现 ==HandlerInterceptor==，会实现preHandle，afterCompletion。一般在preHandle 中会有 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 小程序端token校验 * 统一对请求的合法性进行校验，需要进行2个方面的校验， * 一、请求头中是否携带了authorization * 二、请求头中是否存在userId，如果不存在则说明是非法请求，响应401状态码 * 如果是合法请求，将userId存储到ThreadLocal中 */@Slf4j@Component@EnableConfigurationProperties(JwtTokenManagerProperties.class)public class UserInterceptor implements HandlerInterceptor { @Autowired private JwtTokenManagerProperties jwtTokenManagerProperties; //所有的校验逻辑都是在 前置 里面写的 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //获取token String token = request.getHeader(SecurityConstant.USER_TOKEN); //判断是否为空 if (ObjectUtil.isEmpty(token)){ throw new BaseException(&quot;小程序&quot;,&quot;401&quot;,null,&quot;小程序token失效，请重新登录&quot;); } //解析token Map&lt;String,Object&gt; claims = JwtUtil.parseJWT(jwtTokenManagerProperties.getBase64EncodedSecretKey(), token); //看一下当前的claims里面有没有数据 if (ObjectUtil.isEmpty(claims)){ throw new BaseException(&quot;小程序&quot;,&quot;401&quot;,null,&quot;小程序token失效，请重新登录&quot;); } //获取数据，拿到用户id Long userId = MapUtil.get(claims, Constants.JWT_USERID, Long.class); if (ObjectUtil.isEmpty(userId)){ throw new BaseException(&quot;小程序&quot;,&quot;401&quot;,null,&quot;小程序token失效，请重新登录&quot;); } //存储到threadlocal中 UserThreadLocal.set(userId); return true; } //之后就直接清除 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { UserThreadLocal.remove(); }} 拦截器注册12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * webMvc高级配置 */@Configuration@ComponentScan(&quot;springfox.documentation.swagger.web&quot;)public class WebMvcConfig implements WebMvcConfigurer { @Autowired UserTokenIntercept userTokenIntercept; @Autowired UserInterceptor userInterceptor;//小程序的拦截 //拦截的时候过滤掉swagger相关路径和登录相关接口 private static final String[] EXCLUDE_PATH_PATTERNS = new String[]{&quot;/swagger-ui.html&quot;, &quot;/webjars/**&quot;, &quot;/swagger-resources&quot;, &quot;/v2/api-docs&quot;, // 登录接口 &quot;/customer/user/login&quot;, // 房型列表接口 &quot;/customer/roomTypes&quot;, &quot;/customer/orders/project/**&quot;, &quot;/user/refresh/**&quot;}; /** * 拦截器 */ @Override public void addInterceptors(InterceptorRegistry registry) { //userToken拦截 registry.addInterceptor(userTokenIntercept).excludePathPatterns(ADMIN_EXCLUDE_PATH_PATTERNS); //小程序端接口鉴权拦截器 registry.addInterceptor(userInterceptor).excludePathPatterns(EXCLUDE_PATH_PATTERNS).addPathPatterns(&quot;/customer/**&quot;);//只拦截这路径 } //拦截的时候过滤掉swagger相关路径和登录相关接口 private static final String[] ADMIN_EXCLUDE_PATH_PATTERNS = new String[]{&quot;/swagger-ui.html&quot;, &quot;/webjars/**&quot;, &quot;/swagger-resources&quot;, &quot;/v2/api-docs&quot;, &quot;/customer/**&quot;, &quot;/security/**&quot;, &quot;/common/**&quot;, &quot;/user/refresh/**&quot;}; /** * 资源路径 映射 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //支持webjars registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;); //支持swagger registry.addResourceHandler(&quot;swagger-ui.html&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); //支持小刀 registry.addResourceHandler(&quot;doc.html&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); } public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;; @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() { return builder -&gt; { // 序列化 builder.serializerByType(Long.class, ToStringSerializer.instance); builder.serializerByType(BigInteger.class, ToStringSerializer.instance); builder.serializerByType(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))); builder.serializerByType(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))); builder.serializerByType(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); // 反序列化 builder.deserializerByType(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))); builder.deserializerByType(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))); builder.deserializerByType(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); }; }} 其中本次写的拦截器代码 先注册 12@AutowiredUserInterceptor userInterceptor;//小程序的拦截 12//小程序端接口鉴权拦截器registry.addInterceptor(userInterceptor).excludePathPatterns(EXCLUDE_PATH_PATTERNS).addPathPatterns(&quot;/customer/**&quot;);//只拦截这路径","link":"/2025/02/15/%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}],"tags":[],"categories":[],"pages":[]}